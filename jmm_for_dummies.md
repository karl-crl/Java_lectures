# **Java Memory Model**

**JMM** - это набор гарантий, которые **JVM** дает разработчикам, когда пишут многопоточный код.

**Основные свойства:**
* Атомарность 
* Видимость
* Упорядоченность


# **Атомарность**
Атомарная операция - это операция, у которой мы можем увидеть только состояние до и после (очень похоже по смыслу на транзацию; изменения, которые делает атомарные операции - это типа транзакция).
* Операции над всеми типами, кроме `long` и `double`
являются атомарными.
* По стандарту, `long` и `double` занимают 64 бита.
Поэтому на них НЕТ ГАРАНТИЙ атомарности. Но это не значит,
что они не могут быть реализованы атомарно.

Пример:
``` Java
int a = 0;
long b = 0;
a = 1;
b = -1;
```
Смотрим из другого потока на переменные.  

Возможные значения a:
* 0
* 1

Возможные значени b:
* 0
* -1
* 0xffffffff00000000
* 0x00000000ffffffff


# **Видимость**
Видимость - гарантия, в которой один поток видит те изменения переменных, которые произошли в другом потоке.

Пример: смотрим вторым потоком на вычисления первого:
``` Kotlin
var a: Int = 0
var b: Int = 0

a = 1
b = 2
```

Возможные значения пары `(a, b)`:
* `(0,0)`
* `(1,0)` - когда `a` успело поменяться, а `b` - нет.
* `(1,2)`
* `(0,2)` - тут все сложнее.
> У ядра процессора есть кэш. И периодически информация с кэша выгружается в
> оперативку. Часто кэш сделан в виде стека. Т.е. последние изменения
> загружаются первыми. И в этом случае мы пришли как раз в тот момент, когда
> изменения `b` уже ушли в оперативку, а изменения `a` еще нет.

* Если поток 1 сделал изменения внутри блокировки, отпустил ее, и потом блокировку
взял поток 2, то он видит все изменения, которые сделал поток 1 внутри блокировки.   
**ВАЖНО**: Блокировка должна быть по одному и тому же объекту; поток видит ВСЕ изменения
внутри блокировки, а не только изменения объекта блокировки.
* Поток 1 сделал изменения, а потом создал поток 2. Тогда поток 2 видит все
изменения создателя
* Поток 2 джойнится к потоку 1. Тогда он видит все изменения потока 1.

**ВАЖНО**: Если не выполнен ни один из вариантов, то **НЕТ ГАРАНТИИ** на синхронизацию видимости между потоками.


# **Упорядоченность**
Есть проблема с тем, что наш код оптимизирует кто только может (а кто не может, тоже оптимизирует). JIT, процессор and so on. Поэтому, вообще говоря, у нас нет гарантии, что наши команды будут выполняться именно в том порядке, в котором мы это задумывали.

Пример: выполняем код в потоке 1, во 2 потоке 2 раза последовательно печатаем значение переменной `a`:
``` Kotlin
var a: Int = 0
a = 1
a = 2
```

Возможные выводы в консоль:
* `0, 0`
* `0, 1`
* `0, 2`
* `1, 2` - тут все понятно
* `2, 0`
* `2, 1`
* `...` - могуть быть и какие-то неожиданные результаты.

Это связано с перестановкой команд при оптимизации и с хитрым устройством памяти.
> Есть шина, memory manager и оперативка. Доступ к оперативке медленный,
> поэтому данные из кэша скидываются в MM, а оттуда уже закидываются в оперативку.
> Пусть мы уже поменяли значение `a = 2` и закинули в кэш. Стучимся в MM, чтобы
> спросить значение. Он смотрит, не поступало ли ему из кэша совсем недавно
> значение `a`, видит, что оно равно `2` и отдает нам. Когда мы второй раз
> стучимся в MM, чтобы узнать значение `a`, в него уже подвалила новая инфа из
> кэша, значения `a=2` нет под рукой, и он лезет в оперативку (в которой лежит
> `a = 0`) и отдает нам. Получаем результат `(2, 0)`.

# **`volatile` переменные**

Переменные
* Операции с volatile-переменными всегда атомарны.
* Не кешируются (всегда читаем из оперативки).
* Всегда записываются в общую память.
* Если volatile-ссылка не изменилась, то данные доступные по ней могли не
измениться, т.к. volatile гарантирует лишь корректное чтение/запись
самой ссылки, но не изменяемое состояние объекта по ней.
```kotlin
volatile vat x: A;
x = A() // гарантируем, что это сразу скинеся в общую память
x.foo = S // нет гарантий на то, что это сразу запишется
if (x != null) {
    print(x.foo) // может быть ошибка
}
```
* Делать volatile дорого (поскольку приходится работать с оперативкой,
а не кешом).

Зачем?
* Делаем атомарные long и double.
* Создание объекта через конструктор будет атомарным. 

Пример (про синглтон):
``` Java
// Однопоточная версия
class Foo {
    private static Helper helper = null;
    public static Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
    //......
}
```
Почему не работает при нескольких потоках?
*  Между проверкой в `if` и присваиванием может много всего произойти.

``` Java
// Многоточная версия, но медленная
class Foo {
    private static Helper helper = null;
    public static synchronized Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }
    //......
}
```
Тут все еще есть проблемы:
* `getHelper()` синхронизованный, поэтому каждый раз, когда будем 
пытаться взять `Helper()`, нам придется делать это в 1 поток за раз.
Получается дорого.

#### Шаблон Double-Checked Locking
``` Java
// Неработающая версия
class Foo {
    private static Helper helper = null;
    public static Helper getHelper() {
        if (helper == null) {
            synchronized (Foo.class) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }
    // ........
}
```
Почему не работает? Проблема в строке `helper = new Helper()`
* Эта строка представляет из себя 3 действия: выделение памяти,
выполнение кода конструктора, присвоение ссылки на память переменной.
* Если нет гарантии на упорядоченность, то из другого потока можем
видеть эти действия в каком угодно порядке.
* Например, один поток создал `Helper`, второй увидел, что он уже не
`null`, начал работать, а там ссылка есть, а данные кривые.
> Как может быть так, что ссылка есть, а изменений полей нет?
> Тот же пример с кэшом. Где-то в кеше записаны изменения полей,
> и там же записано то, что `helper` теперь куда-то указывает. И 
> информация про `helper` лежит ближе, кэш нам ее отдал. Но изменений
> в оперативке все еще нет.

``` Java
// Не работает в Java 1.4 и более ранних версиях из-за семантики volatile
class Foo {
    private volatile Helper helper = null;
    public Helper getHelper() {
        if (helper == null) {
            synchronized (Foo.class) {
                if (helper == null) {
                    helper = new Helper();
                }
            }
        }
        return helper;
    }
    // ........
}
```

Но на самом деле, правильно писать так (через вложенный класс):
``` Java
public class Singleton {
    private Sigleton();
    private static class SingletonHolder() {
        public final static Singleton instance = new Singleton();
    }
    
    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}
```
* Статик гарантирует, что объект будет загружен только 1 раз при первом вызове.
* Можно использовать `enum`, там тоже все будет хорошо 
(!!!!! Написать пример, мб на летучке???)


# Еще кусок про атомарность
### Какие бывают атомарные операции?
* Чтение (`get`)
* Запись (`set`)
* Чтение и запись (`getAndSet`)
* Условная запись (`compareAndSet`)
`compareAndSet(old, new)` - если текущее значение равно `old`, то
установить значение в `new`.

**Идиома (lockFreeOperations)**:
``` Java
do {
    old_v = v.get();
    new_v = process(old);
} while (v.compareAndSet(old_v, new_v))
```
> Если 2 потока выполняют функцию одновременно, то в `while` успеет выполнить только один, он изменит переменную. И при этом `compareAndSet` - атомарна.

Такую штуку еще называют **CAS** (сокращение от `compareAndSet`).

**Зачем это все надо?**
* Блокировка дорогая, с ней сложно жить. Хочется какие-то простые 
критические блоки делать без нее.

Почему не делаем так всегда?
* Если `process` тяжелая операция, то постоянно в цикле будем повторять
ее. 

**Пример. Критическая секция на CAS.**
``` Java
// Получение доступа к ресурсу
while (!v.compareAndSet(0,1)); // Активное ожидание

// Действия с ресурсом 

v.set(0); // Освобождение
```
> Получаем блокировку без блокировки
Минусы:
* Цикл - активное ожидание. Стоит делать только для маленьких
критических секций.

### Как реализован `Lock`
Почти везде в Java `Lock` реализован через **CAS**.
Сначала пытаемся в течении небольшого времени через **CAS** сделать, потом
берем блокировку.

### **Примеры счетчика**
**Блокирующий счетчик**
```java
public final class Counter {
    private long value = 0;

    public synchronized long getValue() {
        return value;
    }

    public synchronized long increment() {
        return ++value;
    }
}
```

**"Неблокирующий" счетчик**
```java
public class NonblockingCounter {
    private AtomicInteger value;

    public int getValue() {
        return value.get();
    }

    public int increment() {
        int v;
        do {
            v = value.get();
        } while 
            (!value.compareAndSet(v, v + 1));
        return v + 1;
    }
}
```
