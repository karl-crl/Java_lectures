JMM - набор гарантий, которые дает JVM про код

Основные свойства:
* Атомарность 
* Видимость
* Упорядоченность

### Атомарность
(операция, у которой мы можем увидеть только
состояние до и после; очень похоже по смыслу на транзацию;
изменения, которые делает атомарные операции - это типа 
транзакция; к этому )
  
* Операции над всеми типами, кроме `long` и `double`
являются атомарными.
* По стандарту, `long` и `double` занимают 64 бита.
Поэтому на них НЕТ ГАРАНТИЙ атомарности. Но это не значит,
что они не могут быть реализованы атомарно.

Пример:
```java
int a = 0;
long b = 0;
a = 1;
b = -1;
```
Смотрим из другого потока на переменные.  
Возможные значения a:
* 0
* 1
Возможные значени b:
* 0
* -1
* 0xffffffff00000000
* 0x00000000ffffffff

### Видимость

Гарантия, в которой один поток видит изменения переменных, произведенные
остальными потоками.

Пример: смотрим 2 потоком на вычисления первого:
```kotlin
var a: Int = 0
var b: Int = 0

a = 1
b = 2
```
Возможные значения пары `(a, b)`:
* `(0,0)`
* `(1,0)` - когда `a` успело поменяться, а `b` - нет.
* `(1,2)`
* `(0,2)` - тут все сложнее.
> У ядра процессора есть кэш. И периодически информация с кэша выгружается в
> оперативку. Часто кэш сделан в виде стека. Т.е. последние изменения
> загружаются первыми. И в этом случае мы пришли как раз в тот момент, когда
> изменения `b` уже ушли в оперативку, а изменения `a` еще нет.

* Если поток 1 сделал изменения внутри блокировки, отпустил ее, и потом блокировку
взял поток 2, то он видит все изменения, которые сделал поток 1 внутри блокировки.   
**ВАЖНО**: Блокировка должна быть по одному и тому же объекту; поток видит ВСЕ изменения
внутри блокировки, а не только изменения объекта блокировки.
* Поток 1 сделал изменения, а потом создал поток 2. Тогда потооль:к 2 видит все
изменения создателя
* Поток 2 джойнится к потоку 1. Тогда он видит все изменения потока 1.

**ВАЖНО**: Если не выполнен ни один из вариантов, то НЕТ ГАРАНТИИ на синхронизацию
видимости между потоками.


### Упорядоченность

Есть проблема с тем, что наш код оптимизирует кто только может (а кто не может, 
тоже оптимизирует). JIT, процессор and so on. Поэтому, вообще говоря, у нас
нет гарантии, что наши команды будут выполняться именно в том порядке, в котором
мы это задумывали.

Пример: выполняем код в потоке 1, во 2 потоке 2 раза последовательно печатаем
значение переменной `a`:
```kotlin
var a: Int = 0
a = 1
a = 2
```
Возможные выводы в консоль:
* 0, 0
* 0, 1
* 0, 2
* 1, 2 - тут все понятно
* 2, 0
* 2, 1
* ... - могуть быть и какие-то неожиданные результаты.

Это связано с перестановкой команд при оптимизации и с хитрым устройством памяти.
> Есть шина, memory manager и оперативка. Доступ к оперативке медленный,
> поэтому данные из кэша скидываются в MM, а оттуда уже закидываются в оперативку.
> Пусть мы уже поменяли значение `a = 2` и закинули в кэш. Стучимся в MM, чтобы
> спросить значение. Он смотрит, не поступало ли ему из кэша совсем недавно
> значение `a`, видит, что оно равно `2` и отдает нам. Когда мы второй раз
> стучимся в MM, чтобы узнать значение `a`, в него уже подвалила новая инфа из
> кэша, значения `a=2` нет под рукой, и он лезет в оперативку (в которой лежит
> `a = 0`) и отдает нам. Получаем результат `(2, 0)`.

# volatile переменные

Переменные
* Не кешируются (всегда читаем из оперативки)
* Всегда записываются в общую память
* Если volatile-ссылка не изменилась, то данные доступные по ней могли не
измениться.
* Делать volatile дорого (???)

Зачем?
* Делаем атомарные long и double

Пример (про синглтон):
```java
class Foo {
    private static Helper helper = 
}
```


Правильный синглтон:
* Статик гарантирует, что объект будет загружен только 1 раз при первом вызове.
