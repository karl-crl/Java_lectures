## JVM

Вопросы и дополнения:

(NB: Часть информации взята с АУшного конспекта по Java)

JVM - ПО, которое выполняет код и предоставляет среду для выполнения кода.   
JVM = Интерпретатор + JIT + GC.  
Код компилируется в байт-код, байт-код интерпретируется JVM.

**Что делает JVM?**
* Интерпретирует байт-код => кросс-платформенность.
* Сама управляет памятью (ура, гораздо меньше способов прострелить себе колено).
Необходимо только вручную выделять память, освобождает память JVM. Так же
 не ломает ОС. Например, захотел по какому-то адресу достать, например,
 строчку, а там просто чиселка, и всё ломается. JVM же сама это всё отследит
 и не допустит подобной ситуации. А если программист попытается скастовать,
 например, ArrayList к String, то она это отследит и выдаст красивый и
 аккуратный exception, с которым можно удобно работать.
* В JVM чаще всего есть JIT (just in time компиляция), которая умеет делать
[много полезных плюшек](#jit).

 
**Управление памятью**:

JVM сама выделяет (по запросу) и освобождает память. Удаляет объекты, которые недостижимы со стеков (м.б. несколько потоков)
и из статической памяти.

## Некоторый синтаксис

Есть жестко закрепленные и принятые соглашения по code style: code conventions.
Те, кто их не соблюдают, горят в аду.
* Названия всех классов с большой буквы (и CamelCase).
* Все функции, методы и поля с маленькой буквы.
* Названия всех констант с большой буквы и разделяются подчеркиваниями.
* `this`  пишется только там, где необходимо для компиляции.

Некоторая важная информация:
* Для запуска программы, в ней должен быть класс, у которого есть метод 
```
public static void main(String[] args)
```
`public` - чтобы мог кто угодно вызывать функцию.   
`static` - чтобы можно было запустить вне класса.
* Порядок вычислений аргументов функции определен! Слева направо.
* В отличие от C++, где массив - это просто какой-то кусок памяти, в Java массив - это объект,
который имеет длину, чтобы можно было ее узнать и не вылезти за границы массива.
* В Java есть package - похоже на namespace. Принято, чтобы классы находились внутри пакетов.
* По-умолчанию все методы `package private`.

## Модификаторы
Всего 4 модификатора доступа:
* public (видно все и отовсюду)
* protected (видимость в наследниках + package private)
* package private (по-умолчанию, видимость внутри одного пакета)
* private (видно только внутри класса)

Кроме этого есть еще ряд модификаторов:
- модификатор static применяется для создания статических методов и переменных класса;
- модификатор final используется для завершения реализации классов, методов и переменных;
- модификатор abstract необходим для создания абстрактных классов и методов;
- модификаторы synchronized и volatile используются в Java для многопоточности;
- есть еще, но их пока не проходили.

### Модификатор final

**Переменные**:
* Переменная c `final` может быть инициализирована только 1 раз.
* `final` переменные **не инициализируются по-умолчанию**, необходимо явно присвоить
значение при объявлении или в конструкторе, иначе - ошибка компилляции.
* Ссылочная переменная, объявленная как final, никогда не может быть назначена для обозначения другого
объекта. Однако поля объекта могут быть изменены. Также это справедливо и для массивов, потому
что массивы являются объектами: массив может быть изменен, но переменная всегда будет ссылаться
на тот же самый массив.  
`final` переменная =  ссылка в C++.
* С переменными модификатор final часто используется совместно со static, чтобы сделать переменную
класса константой. Подобные переменные должны быть инициализированы во время объявления или в
статическом блоке.  
**ВАЖНО**:
`final static` лишь говорит, что за переменной закреплен какой-то объект и на
другой мы его поменять не можем. Но его содержание не обязательно неизменяемо.
Например:
`final static ArrayList<String>` вполне себе мутабельный.
* Метод c `final` не может быть переопределен. Аргументы методов, обозначенные
 как `final`, предназначены только для чтения, при попытке изменения будет
 ошибка компиляции.
* Нельзя создать экземпляр абстрактного класса. Если класс объявлен
как abstract, то единственная цель для него - быть расширенным
через наследование. Класс не может быть одновременно `abstract` и `final`,
так как класс с модификатором final не может быть расширенным.
* От класса с final нельзя наследоваться. Поэтому все его методы не могут
быть переопределены и неявно также становятся финальными.
* Абстрактные методы тоже не могут быть `final`.
* `private` методы неявно являются `final`. `final` блокирует метод от переопределения
в классах наследниках. `private` метод и так не может быть переопределен в
наследниках, т.к. он там недоступен.
* Конструктор не может быть `final` (ошибка компиляции). Можно сказать, что
любой конструктор уже является `final`. Если какой-нибудь наследник её
переопределит, то с инициализацией полей базового класса всё может быть
очень грустно. Поэтому в конструкторе наследника необходимо сначала
вызывать super конструктор. Также стоит заметить, что имя конструктора
жёстко задано именем класса, и у наследника имя конструктора будет другое.
* Если у класса лишь 1 конструктор, он не может быть `final`
(ошибка компиляции).


## Немного про JIT и разогрев JVM
<a name="jit"></a>
В самом примитивном виде JVM исполняет код следующим образом: байткод
представляет собой набор инструкций для определённого вида стек-машины.
При запуске программы JVM интерпретирует его инструкция за инструкцией и
эмулирует исполнение на этой машине. Но это, очевидно, очень медленно работает,
по сравнению с тем, если бы код изначально был бы скомпилирован в машинный код.
Для того, чтобы это исправить, в JVM есть JIT (Just In Time) компилятор,
который умеет компилировать байткод в машинный код прямо во время исполнения
программы. Фишка jit'а в том, что JVM анализирует исполняемый код, находит
участки кода, которые выполняются чаще всего, и компилируются, в первую
очередь, именно они (единицей компиляции выступает один метод).
После компиляции при вызове этого метода вызывается уже машинный код,
из-за чего производительность увеличивается.

Или другой пример: 
```
interface A {
    fun foo()
}

class A1 : A {
    override fun foo() {...}
}

fun test(a: A) {
    a.foo() // (1)
}
```
В позиции (1) происходит интерфейсный вызов, поэтому по-хорошему каждый раз
при вызове этой функции нужно лезть в таблицу виртуальных функций объекта a,
находить адрес для foo и только после этого её вызывать. Однако если в JVM
загружена только одна импементация A, то JIT может в таких местах сразу
подставлять конкретный адрес для foo, что также увеличивает производительность.

**Разогревом** называется временной промежуток, за который JVM собирает информацию о коде и компилирует JIT'ом все горячие места. Т.е. по ходу работы программы JVM собирает всякую информацию и использует ее при следующем запуске программы, чтобы соптимизировать.
