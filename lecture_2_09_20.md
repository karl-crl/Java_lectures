## 2.09.20

## TODO
* Почитать про исключения и их типы, которые тут есть
* 

#  Многопоточное программирование в Java

Пакеты:
* `java.lang`
* `java.util.concurrent`

Кусок стандартной библиотеки, хорошо реализовано,
и так хорошо работает.

## Потоки

* Отдельный стек вызовов у каждого потока.
* Причем у этих потоков **ОБЩАЯ** память.

У процессов память разная. У потоков общая.
Возникают некоторые проблемы из-за этого.

* Java-поток != поток в ОС.
* У джавы свой планировщик потоков. Он привязывается (если может) 
к планировщику ОС.  
  
Много потоков, мало ядер => есть планировщик потоков, который дает время
от времени каждому потоку поработать.
Просит поток свалить, загружает новый.

Джавовские потоки привязываются к ОС потокам, если есть многопоточность. 
Иначе джава сама это делает.

**Категории потоков**:
* демоны
* пользовательские

Джава-программа считается законченной, если все польз. потоки завершились.
На демонов ей пофиг, она их прибивает.


## Создание потоков

Две самые главные вещи для создания потока:
* Интерфейс Runnable (то, что может запускаться)
* Класс Thread

**Интерфейс Runnable**

Методы:
* `public void run()` - содержит стек вызовов, которые будут исполняться
в потоке.

**Класс Thread**

* Реализует интерфейс Runnable.
* Thread - поток, который будет маппиться на поток ОС.

Конструкторы:
* `Thread()`
* `Thread(Runnable target)`
* `Thread(Runnable target, String name)` - с именем проще искать и дебажить.
* `Thread(String name)`

Методы:
* `bublic void run()`
* `public void start()` - запускает поток.

**ВАЖНО**: Если хотим запустить поток, то пишем `start`. А `run` просто
запустит в текущем потоке код треда.

**Пример создания потока**:
```
// Создание потока
Thread t = new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello");
    }
});
// Запуск потока
t.start();
```

Плохой способ это сделать:
```
// Создание потока
Thread t = new Thread() {
    public void run() {
        System.out.println("Hello");
    }
};
// Запуск потока
t.start();
```
Почему плохой:   
Если мы взяли класс и переопределили метод, то мы отнаследовались. 
1) Т.е. мы запретили классу наследоваться от чего-то еще.
2) Не можем передать один `Runnable` в неcколько потоков
(стандартная практика).

Пример сл 10:
```
public class Starter {
    public static void main(String[] args) {
        NameRunnable nr = new NameRunnable();
        Thread one = new Thread(nr);
        Thread two = new Thread(nr);
        Thread three = new Thread(nr);
        one.setName("Первый");
        two.setName("Второй");
        three.setName("Третий");
        one.start();
        two.start();
        three.start();
    }
}
class NameRunnable implements Runnable {
    public void run() {
        for (int x = 1; x <= 3; x++) {
            System.out.println("Запущен " + Thread.currentThread().getName() + ", x равен " + x);
        }
    }
}
```
Что выведет?:
* Строчка не прервется посередине, т.к. `println` - блокирующая операция.
* Внутри одного потока строки упорядочены, между потоками - как угодно.
 
## Свойства потока:
* id - не связан с id в ОС.
* name - если не задано, то генерируется JVM; несколько потоков могут
иметь одно и то же имя.
* priority - как часто будет потоку выдаваться время на поработать.
* daemon - поток-демон.   
 **ВАЖНО** После старта свойства не меняются.
 
##  Состояния потока:

**Идейно**:

![image](pics/thread_1.png)

t.start() : New -> Runnable   
**ВАЖНО**: Поток НЕ может перейти из Waiting/blocking сразу в Running!

Что происходит после thread.start():
1) Инстанс потока в ОС (сложно, долго)
2) Инициализируется стека вызовов.
3) На стек загружается точка входа в метод thread.run() и начинает
исполняться.


**С точки зрения Java**:

Состояние потока можно проверить двумя командами:
* `int getState()`
* `boolean isAlive()`

|  `getState()` | `isAlive()` |
|---------------|-------------|
| NEW           |             |
| RUNNABLE      | +           |
| BLOCKED       | +           |
| WAITING       | +           |
| TIMED_WAITING | +           |
| TERMINATED    |             |

Состояния running нет, т.к. если поток ответил на вопрос, и runnable, то 
он running **???** 
  
## Взаимодействие с потоками

* Создание потока
* Запуск потока
* Ожидание окончания потока (join)
* Прерывание потока (interrupt)
* Засыпание потока (sleep)
* Переключение потока (yield)

Все эти методы кидают `InterruptedException`.

### Sleep

`static void sleep(long millis)`

Если не удобно передавать время в миллисекундах, то можно использовать
` TimeUnit.SECONDS.sleep(secs/min/...)`.

* sleep - статический, т.е. отправляет в сон **текущий** поток !!!!!!!!!
* Отправляет поток в TIMED_WAITING
* Можно усыпить только свой поток! (всм, насильно, без backdoor).

### Приоритеты и yield
(в реальности не нужно, но на летучке могут спросить)
* Приоритет - условно, насколько часто ОС дает потоку поработать.   
* С точки зрения JVM приоритетов 10 штук. 
* У потока есть поля:
* * `static int MAX_PRIORITY` (10) - максимальный приоритет, который поток может
иметь.
* * `static int NORM_PRIORITY` (5)
* * `static int MIN_PRIORITY` (1)
* Приоритетность потоков как-то транслируется планировщику потоков ОС.
* Лучше всего использовать константы приоритетов, т.к. они хорошо транслируются
в любой ОС. Свои могут криво работать.

`void setPriority(int newPriority)` - устанавливает приоритет.

* `yield` говорит планировщику "а мб ты другой поток возьмешь?"
* Планировщик может согласиться или нет.
* Обычно эта команда почти никогда мгновенно не работает.

**ВАЖНО**: Нет возможности удержаться на процессоре. Можно только изначально
задать приоритет повыше.

### join

* `void join()` -- наш поток будет ждать, пока t не завершит работу.
* `void join(long millis)` -- ожидать до завершения или истечения времени.
* `void join(long millis, int nanos)`

### interrupt

* `interrupt()` - рекомендует другому потоку закончить работу (устанавливает
флаг прерывания).

### InterruptedException
Проблема с interrupt: пусть есть поток, который уснул на 2 часа. Другой поток
захотел его прервать. Когда первый поток проснется, то он может как-то
отреагировать на флаг. Но 2 часа точно придется ждать. Не самый оперативный
способ связи.

Поэтому все методы, который отправляют поток на длительное ожидание, бросают
`InterruptedException`.

* Выкидывается, когда кто-то пытается прервать поток, когда он спит.
Т.е. если вызвать `myLittleThread.interrupt()`
* Может генериться случайно (т.е. **всегда надо проверять, что поток
действительно пытались прервать** через `isInterrupted()`)
* Нет общей договоренности, можно ли игнорировать `InterruptedException`.

Пример, когда исключение НЕ игнорируется:
```
class Worker implements Runnable {
    public void run() {
        try {
            while (!Thread.interrupted()) {
                // Полезные действия
            }
        } catch (InterruptedException e) {
        }
        // Исполнение потока прервано
        // Поток заканчивает работу
    }
}
```

## Блокировки в Java
* Любой объект может быть блокировкой.
Чтобы его сделать:
```
synchronized(obj){//получение блокировки
    код
//снимает блокировку}
```
* `synchronized` - не метод, а ключевое слово.
* В Джава не надо самим спускать блокировку.
* Если `obj` занят (т.е. кто-то вызвал на нем synchronized), то текущий
поток переходит в состояние BLOCKED и ждет, пока  объект не освободится.
* synchronized не позволяет сделать какую-то другую задачу, если поток ждет
ресурс (но есть другие штуки, которые позволяют).
* Можно сделать метод ЭКЗЕМПЛЯРА синхронизированным:
```
public synchronized int getValue() { ... }
```
* Эквивалентно (почти, потому что JIT компиллятору проще оптимизировать первое)
```
public int getValue() {
    synchronized (this) { ... }
}
```
* Можно сделать метод КЛАССА синхронизированным:
```
Class Example {
    public static synchronized int getValue() { ... }
```
* Эквивалентно (почти)
```
public int getValue() {
    synchronized (Example.class) { ... }
}
```

**ВАЖНО**: При вызове `yeild`, `synchonized`, `join` поток УДЕРЖИВАЕТ
ВСЕ блокировки.

Пример:
```java
sychronized(o) {
    this.sleep(10000)
    // пока поток спит, никто другой не сможет взять блокировку
}
```

### Как работает планировщик потоков.

Очень приближенно. Поток - это книжка. Эти книжки лежат в стопке. Планировщик
читает верхнюю книгу. Если он читает ее долго (1000 мсек), то он ее закрывает,
кладет вниз и открывает верхнюю. Перед тем как начать ее читать, он проверяет,
есть ли у нее все необходимые блокировки. Если есть, то он ее запускает. Если
нет, то он проверяет, можно ли захватить все необходимые блокировки. Если да,
то захватывает, иначе кидает ее вниз.



## Несколько многопоточных паттернов проектирования

### Паттерн "Производитель-потребитель"

* есть один или несколько потоков, которые производят данные (производители).
Они складывают данные в очередь.
* один или несколько потоков, которые потребляют данные. Они забирают данные из
очереди.

Будем рассматривать пример с n производителей, m потребителей, очередь размера 1.

В чем проблема:
* много производителей => производителю надо ждать, чтобы положить данные в
очередь.
* потребителю надо сидеть и ждать, пока что-то появится в очереди

> Q: Что будет, если не убить поток-потребитель? Он будет вечно ждать?
> A: Да. Это, например, как чтение из консоли. Если мы не прервем программу,
> то будем вечно ждать нового сообщения.

#### Реализация методов
Интерфейс очереди:
```java
class Queue {
    private Object data;
    public void set(Object data) {}
    public Object get() {}
}
```


**Установка значения**

```java
public void set(Object data) {
    while (true) {
        synchronized(this) {
            if (this.data == null) {
                this.data = data;
                break;
            }   
        }   
    }
}
```
Комментарии: если поменять `while` и `synchronized` местами, то все сломается.
Не можем выйти из цикла, пока кто-то не заберет объект из очереди. Но объект
можно забрать, только если он не заблокирован, а он заблокирован.

Спойлер: этот код - говно. Почему?
1) Если производителей много, то они все будут крутиться в ожидании своей очереди
на выкладывание данных. Это затратно.   
Лучше сделать что-то в стиле "усни, пока не заберут данные из очереди".
2) Этот код долгий. В начале каждой итерации цикла захватываем, а потом
освобождаем блокировку.   
* Захват блокировки - тяжелая операция. Для этого надо выйти за пределы своего
потока, обратиться к менеджеру потоков, с ним пообщаться, мб еще уснуть.   
* Отдача блокировки - тоже тяжелая операция.

**Получение значения**

```java
public Object get() {
    while (true) { // Активное ожидание
        synchronized(this) {
            if (this.data != null) {
                Object d = this.data;
                this.data = null;
                return d;
            }   
        }   
    }
}
```

#### Мониторы и условия

В классе `Object` есть 3 метода для общения между потоками:
* `wait(time?)` - ожидание. При ожидании **БЛОКИРОВКА СНИМАЕТСЯ**.   
> Поток в соcтоянии Running. Когда поток засыпает, он запоминает все блокировки,
которыми владел, и отпускает их. Переходит в состояние Waiting. Когда он
просыпается, то ему надо захватить обратно все блокировки. Переход в состояние
Blocking. Когда он захватил все блокировки обратно, он готов к работе (состояние
Runnable).
* `notify()` - извещение одно (случайного) из ждущих потоков. **НЕ СНИМАЕТ
БЛОКИРОВКУ**.
* `notifyAll()` - извещение всех ждущих потоков. **НЕ СНИМАЕТ БЛОКИРОВКУ**.

**ВАЖНО**:
* Нельзя делать эти методы без блокировки (иначе `java.lang.IllegalMonitorStateException`)
* Бросают `IllegalMonitorStateException`.
* Возможно внезапное пробужение (т.е. без `notify()`). Поэтому все `wait()`
надо делать в цикле:
  ```java
  while(условие) {
      wait();
  }
  ```

Другие версии методов:
```java
public synchronized void set(Object data) throws InterruptedException {
    while (this.data != null) {
        this.wait(); // Пассивное лжидание
    }
    this.data = data;
    this.notify();
}

public synchronized Object get() throws InterruptedException {
    while (data == null) {
        wait(); // пассивное ожидание
    }
    Object d = data;
    data = null;
    notify();
    return d;
}
```

Проблема: функция `notify()` уведомляет КОГО-ТО. Это может быть другой
производитель. И мы не знаем, кого она разбудит.

Решение: будим всех. На самом деле, тоже не самое хорошее решение, т.к. **???**
Но пока будем делать так.

```java
public synchronized void set(Object data) {
    while (this.data != null) {
        this.wait();
    }
    this.data = data;
    notifyAll();
}

public synchronized Object get() {
    while (data == null) {
        wait();
    }
    Object d = this.data;
    this.data = null;
    notifyAll();
    return d;
}
```

**Политика передачи блокировки**:
* честная (получает блокировку тот, кто пришел первый)
* случайная


### Паттерн Задания-Работники
Отличие от паттерна Производитель-потребитель: Задание хочет получить обратно
какой-то ответ о выполнении или результат.

Решение с помощью монитора:
#### Задание:
```java
sync(task) {
    sync(queue) {
        queue.add(task);
        queue.notifyAll();
    }
    task.wait();
}
```

#### Работник
```java
sync(queue) {
    while (queue.isEmpty()) {
        queue.wait();
    }
    Task t = queue.get();
}
t.notify();
```

Тут нет проблемы с тем, что мы разбудим кого-то не того: разные сущности сидят
в ожидании по разным объектам (очередь, таска).