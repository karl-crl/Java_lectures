## 2.09.20

#  Многопоточное программирование в Java

Пакеты:
* `java.lang`
* `java.util.concurrent`

Кусок стандартной библиотеки, хорошо реализовано,
и так хорошо работает.

## Потоки

* Отдельный стек вызовов у каждого потока.
* Причем у этих потоков **ОБЩАЯ** память.

У процессов память разная. У потоков общая.
Возникают некоторые проблемы из-за этого.

* Java-поток != поток в ОС.
* У джавы свой планировщик потоков. Он привязывается (если может) 
к планировщику ОС.  
  
Много потоков, мало ядер => есть планировщик потоков, который дает время
от времени каждому потоку поработать.
Просит поток свалить, загружает новый.

Джавовские потоки привязываются к ОС потокам, если есть многопоточность. 
Иначе джава сама это делает.

**Категории потоков**:
* демоны
* пользовательские

Джава-программа считается законченной, если все польз. потоки завершились.
На демонов ей пофиг, она их прибивает.


## Создание потоков

Две самые главные вещи для создания потока:
* Интерфейс Runnable (то, что может запускаться)
* Класс Thread

**Интерфейс Runnable**

Методы:
* `public void run()` - содержит стек вызовов, которые будут исполняться
в потоке.

**Класс Thread**

* Реализует интерфейс Runnable.
* Thread - поток, который будет маппиться на поток ОС.

Конструкторы:
* `Thread()`
* `Thread(Runnable target)`
* `Thread(Runnable target, String name)` - с именем проще искать и дебажить.
* `Thread(String name)`

Методы:
* `bublic void run()`
* `public void start()` - запускает поток.

**ВАЖНО**: Если хотим запустить поток, то пишем `start`. А `run` просто
запустит в текущем потоке код треда.

**Пример создания потока**:
```
// Создание потока
Thread t = new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello");
    }
});
// Запуск потока
t.start();
```

Плохой способ это сделать:
```
// Создание потока
Thread t = new Thread() {
    public void run() {
        System.out.println("Hello");
    }
};
// Запуск потока
t.start();
```
Почему плохой:   
Если мы взяли класс и переопределили метод, то мы отнаследовались. 
1) Т.е. мы запретили классу наследоваться от чего-то еще.
2) Не можем передать один `Runnable` в неcколько потоков
(стандартная практика).

Пример сл 10:
```
public class Starter {
    public static void main(String[] args) {
        NameRunnable nr = new NameRunnable();
        Thread one = new Thread(nr);
        Thread two = new Thread(nr);
        Thread three = new Thread(nr);
        one.setName("Первый");
        two.setName("Второй");
        three.setName("Третий");
        one.start();
        two.start();
        three.start();
    }
}
class NameRunnable implements Runnable {
    public void run() {
        for (int x = 1; x <= 3; x++) {
            System.out.println("Запущен " + Thread.currentThread().getName() + ", x равен " + x);
        }
    }
}
```
Что выведет?:
* Строчка не прервется посередине, т.к. `println` - блокирующая операция.
* Внутри одного потока строки упорядочены, между потоками - как угодно.
 
## Свойства потока:
* id - не связан с id в ОС.
* name
* priority - как часто будет потоку выдаваться время на поработать.
* daemon - поток-демон.   
 **ВАЖНО** После старта свойства не меняются.
 
##  Состояния потока:

**Идейно**:

![image](pics/thread_1.png)

t.start() : New -> Runnable   
**ВАЖНО**: Поток НЕ может перейти из Waiting/blocking сразу в Running!

Что происходит после thread.start():
1) Инстанс потока в ОС (сложно, долго)
2) Инициализируется стека вызовов.
3) На стек загружается точка входа в метод thread.run() и начинает
исполняться.


**С точки зрения Java**:

Состояние потока можно проверить двумя командами:
* `int getState()`
* `boolean isAlive()`

|  `getState()` | `isAlive()` |
|---------------|-------------|
| NEW           |             |
| RUNNABLE      | +           |
| BLOCKED       | +           |
| WAITING       | +           |
| TIMED_WAITING | +           |
| TERMINATED    |             |

Состояния running нет, т.к. если поток ответил на вопрос, и runnable, то 
он running **???** 
  
## Взаимодействие с потоками

* Создание потока
* Запуск потока
* Ожидание окончания потока (join)
* Прерывание потока (interrupt)
* Засыпание потока (sleep)
* Переключение потока (yield)

Все эти методы кидают `InterruptedException`.

### Sleep

`static void sleep(long millis)`

Если не удобно передавать время в миллисекундах, то можно использовать
` TimeUnit.SECONDS.sleep(secs/min/...)`.

* sleep - статический, т.е. отправляет в сон **текущий** поток !!!!!!!!!
* Отправляет поток в TIMED_WAITING
* Можно усыпить только свой поток! (всм, насильно, без backdoor).

### Приоритеты и yield
(в реальности не нужно, но на летучке могут спросить)
* Приоритет - условно, насколько часто ОС дает потоку поработать.   
* С точки зрения JVM приоритетов 10 штук. 
* У потока есть поля:
* * `static int MAX_PRIORITY` (10) - максимальный приоритет, который поток может
иметь.
* * `static int NORM_PRIORITY` (5)
* * `static int MIN_PRIORITY` (1)
* Приоритетность потоков как-то транслируется планировщику потоков ОС.
* Лучше всего использовать константы приоритетов, т.к. они хорошо транслируются
в любой ОС. Свои могут криво работать.

`void setPriority(int newPriority)` - устанавливает приоритет.

* `yield` говорит планировщику "а мб ты другой поток возьмешь?"
* Планировщик может согласиться или нет.
* Обычно эта команда почти никогда мгновенно не работает.

**ВАЖНО**: Нет возможности удержаться на процессоре. Можно только изначально
задать приоритет повыше.

### join

* `void join()` -- наш поток будет ждать, пока t не завершит работу.
* `void join(long millis)` -- ожидать до завершения или истечения времени.
* `void join(long millis, int nanos)`

### interrupt

* `interrupt()` - рекомендует другому потоку закончить работу (устанавливает
флаг прерывания).

### InterruptedException
Проблема с interrupt: пусть есть поток, который уснул на 2 часа. Другой поток
захотел его прервать. Когда первый поток проснется, то он может как-то
отреагировать на флаг. Но 2 часа точно придется ждать. Не самый оперативный
способ связи.

Поэтому все методы, который отправляют поток на длительное ожидание, бросают
`InterruptedException`.

* Выкидывается, когда кто-то пытается прервать поток, когда он спит.
* Нет общей договоренности, можно ли игнорировать `InterruptedException`.

Пример, когда исключение НЕ игнорируется:
```
class Worker implements Runnable {
    public void run() {
        try {
            while (!Thread.interrupted()) {
                // Полезные действия
            }
        } catch (InterruptedException e) {
        }
        // Исполнение потока прервано
        // Поток заканчивает работу
    }
}
```

## Блокировки в Java
* Любой объект может быть блокировкой.
Чтобы его сделать:
```
synchronized(obj){//получение блокировки
    код
//снимает блокировку}
```
* `synchronized` - не метод, а ключевое слово.
* В Джава не надо самим спускать блокировку.
* Если `obj` занят (т.е. кто-то вызвал на нем synchronized), то текущий
поток переходит в состояние BLOCKED и ждет, пока  объект не освободится.
* synchronized не позволяет сделать какую-то другую задачу, если поток ждет
ресурс (но есть другие штуки, которые позволяют).
* Можно сделать метод ЭКЗЕМПЛЯРА синхронизированным:
```
public synchronized int getValue() { ... }
```
* Эквивалентно (почти, потому что JIT компиллятору проще оптимизировать первое)
```
public int getValue() {
    synchronized (this) { ... }
}
```
* Можно сделать метод КЛАССА синхронизированным:
```
Class Example {
    public static synchronized int getValue() { ... }
```
* Эквивалентно (почти)
```
public int getValue() {
    synchronized (Example.class) { ... }
}
```

