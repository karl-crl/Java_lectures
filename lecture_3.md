# ООП и исключения

## Классы и ООП

Объявление класса начинается с ключевого слова `class`. Перед ним могут указаны модификаторы класса.

Тело класса пишется в фигурных скобках. В отличие от C++, нельзя (вообще говоря, в Java в этом нет необходимости) писать объявление класса в одном файле, а определение – в другом.

Классы хранятся в файлах с расширением `.java`. Если файл называется `ClassName.java`, то в нём обязательно должен находиться только один публичный класс, и его название должно совпадать с именем файла.

> Так как корректные идентификаторы в Java не ограничиваются таблицей ASCII, то можно создавать необычные имена классов или любых других идентификаторов. Например, класс `回国.java` компилируется безо всяких ограничений.
>
> Однако, скорее всего, IDE выдаст warning за использование символов не из ASCII в качестве идентификатора

Объявление полей синтаксически не отличается от объявления переменных (большинство ограничений носят семантический характер). Поля, не инициализированные явно, инициализируются значениями по умолчанию.

То есть, нулём соответствующего типа для примитивов или результатом вызова дефолтного конструктора для объектов.

Методы объявляются привычным образом: указываются модификаторы, затем тип возвращаемого значения, имя метода, список формальных параметров, а затем – тело в фигурных скобках.

```java
// Файл ExampleClass.java

class ExampleClass {
    int value;

    int getValue() {
        return value;
    }
}
```

В Java допускается создание нескольких методов с одинаковым именем, но разными типами аргументов. Это называется *перегрузка* (*overload*) методов (не путать с переопределением (*override*)).

> В зависимости от изученных ранее языков, может показаться: зачем это уточнять? В каких языках нет перегрузки функций или методов?
>
> В языках более низкого уровня. Например, C.

### Конструктор

Конструктор – особый метод класса. Его имя строго совпадает с именем класса, а возвращаемое значение отсутствует. Он предназначен для того, чтобы инициализировать созданный объект класса. Например, там можно следуя какой-то логике инициализировать поля класса или захватывать ресурсы, которыми будет владеть объект на протяжении его времени жизни.

**Важно!** После вызова конструктора объект класса должен находиться в согласованном состоянии (то есть, никакие инварианты не должны быть нарушены). Не соблюдение этого правила влечёт за собой возрастание сложности поддержки и использования класса в дельнейшем.

Если не объявлен ни один конструктор, автоматически будет сгенерирован конструктор по умолчанию (без параметров).

Конструктор можно вызвать, используя ключевое слово `new` следующим образом: `Pizza pizza = new Pizza("Hawaiian", 30);`. В отличие от C++, круглые скобки в конструкторе без параметров опускать запрещено – это приводит к ошибке компиляции.

#### Делегирование конструкторов

Так называют ситуацию, когда один конструктор передаёт по цепочке вызов какому-то другому конструктору, возможно, уточнив параметры. С этой точки зрения конструктор ничем не отличается от метода: их также можно перегружать.

Однако, у одного экземпляра класса конструктор может быть вызван только единожды. Поэтому, вызывать один конструктор из другого можно исключительно с помощью делегирования. Вот, как это выглядит:

```java
public class Color {
    private final String name;

    Color() {
        this("red"); // Делегирование конструктора
    }

    Color(String name) {
        this.name = name;
    }
}
```

Такая конструкция (вызов `this` с соответствующими параметрами) обязательно должна находиться на первой непустой строке в теле конструктора. Во всех остальных местах такая конструкция запрещена.

> Также, на этом примере можно увидеть один из вариантов задания значений полям по умолчанию: делегируя конструкторы с соответствующими значениями параметров.

### Деструктор

Коротко говоря, его нет.

Если разбираться более детально: в Java нет необходимости в наличии деструктора, так как сборка мусора осуществляется автоматически. Однако, только что говорилось про то, что в конструкторе можно захватить ресурсы – как их тогда освобождать?

Устаревшим методом является переопределить метод `void finalize()`, унаследованный от `java.lang.Object`. Сейчас этот метод deprecated. В виду того, как устроен сборщик мусора, у программиста отсутствует хоть какая-нибудь гарантия, когда метод `finalize` будет вызван. Гарантируется, что этот метод вызовется ровно один раз перед тем, как сборщик мусора уничтожит объект. Однако когда именно запустится сборщик мусора – не ясно. Более плохой ситуацией является, если из метода `finalize` "утечёт" ссылка на `this`. Компилятор не может это запретить, однако ни к чему хорошему это не приведёт.

 Собственно, это и послужило поводом запрещения к использованию этого метода и переосмысления дизайна концепции освобождения ресурсов.

> **Зачем это вообще может понадобиться?**
>
> Например, на некоторых ОС если не освободить дескриптор файла, в который только что производилась запись, произойдёт следующее:
> * Какой-то объём данных будет храниться в памяти, ожидая команды сброса содержимого буфера на диск
> * Приложение, которое производило запись в файл, завершается, перед этим не закрыв файловый дескриптор
> * Текущие изменения в буфере не будут сброшены на диск, а будут отвергнуты
>
> Есть более "современный" пример необходимости освобождения ресурсов. Пусть приложение в качестве ресурса создаёт подключение к некоторой маленькой базе данных. Если подключения создаются достаточно часто, а у базы данных есть ограничение на количество активных соединений, то в какой-то момент, если не освобождать ресурс "соединение с базой данных", она будет отказывать в создании новых подключений.

Современным способом является сделать так, чтобы класс реализовывал интерфейс `AutoCloseable`. Это добавит в публичный интерфейс класса метод `void close()`, в котором можно будет описать необходимую логику для освобождения ресурсов.

Помимо всего прочего, этот интерфейс также даёт следующие преимущества:

* Чтобы метод `close` был вызван автоматически, вызов захват ресурсов классом можно сделать в секции try-with-resources;
* Сам факт, что класс реализует интерфейс `AutoCloseable` уже будет говорить программистам, которые будут с этим классом работать о том, что данный класс может захватывать какие-то ресурсы и требует вызова метода `close` для их освобождения

### Наследование

В Java для наследования используется ключевое слово `extends`. Множественного наследования нет, справа от `extends` может быть указан только один класс.

На вершине иерархии наследования каждого класса находится `java.lang.Object`. Если у какого-то класса явно не указывается класс-родитель, значит этот класс всё равно неявно наследуется от `Object`.

Синтаксис:
```java
class HashMap extends AbstractMap {

}
```

Похожим на [делегирование конструкторов](#делегирование=конструкторов) синтаксисом обладает вызов родительских конструкторов. Единственное существенное отличие (помимо того, к конструктору какого класса идёт обращение) в том, что вместо ключевого слова `this` используется слово `super`. Также остаётся правило про то, что это выражение должно являться первым в теле конструктора.

### Интерфейсы

Интерфейс (в ООП в целом) определяет некоторый набор методов, который должны иметь все классы, реализующие этот интерфейс. В нём находятся объявления (сигнатура) методов, которые будут у всех классов, реализующих этот интерфейс. А задача самих этих классов – предоставить реализацию соответствующим методам.

В отличие от наследования, в Java допустима реализация сразу нескольких интерфейсов одним и тем же классом.

Интерфейс определяется подобно классу, только вместо ключевого слова `class` используется ключеовое слово `interface`:

```java
interface Drawable {
    void draw();
}

class Player implements Drawable, Serializable {
    void draw() {
        // ...
    }
}
```

* В интерфейсе все методы по умолчанию имеют модификатор доступа `public`;
* Все поля в интерфейсе – `public static final`;
* С Java 8 стало возможным объявлять реализацию метода в интерфейсе по умолчанию с помощью ключевого слова `default`;
* С Java 8 в интерфейс стало позволено добавлять статические методы

## Инициализация

### Инициализация переменных

Всё, что про это нужно знать: переменные инициализировать обязательно. При этом, объявление и инициализация могут быть двумя отдельными выражениями. Главное, чтобы между ними ни в каком другом выражении не осуществлялся доступ на чтение из неинициализированной переменной. В отличие от C++ это приведёт к ошибке компиляции (в C++ такого поведения можно добиться, указав соответствующий флаг при компиляции).

```java
int x; // Объявление
x = 1; // Инициализация
```

### Инициализация полей

В отличие от переменных, поля можно оставлять "неинициализированными". Это приведёт к тому, что при создании экземпляра класса (или в *другое* время, если поле статическое) поле будет инициализированно нулём соответствующего типа для примитивов или результатом вызова дефолтного конструктора для объектов.

```java
class Test {
    int n = 13;
    int i = foo(n);

    int foo(int num) {
        return num * num - 1;
    }
}
```

Этот пример говорит о том, что при инициализации полей можно вызывать методы класса (только статические методы, если поле статическое), а также обращаться к другим **уже инициализированным** полям.

### Секции инициализации

В Java существуют так называемые *секции инициализации* и *статические секции инициализации*. Они выглядят следующим образом:

```java
public class StaticTest {
    static int i;

    int j;
    int h;

    static { // Статическая секция инициализации
        i = 25;

        System.out.println("Hello1");
    }

    { // Секция инициализации
        j = 8;
        h = 3;

        System.out.println("Hello2");
    }

    public static void main(String[] args) {
        System.out.println("Hello3");

        StaticTest t = new StaticTest();
    }
}

// На экран будет выведено:
//  Hello1
//  Hello3
//  Hello2
```

Сначала выполняется статическая секция инициализации, потому что вызывается статический метод класса `StaticTest`, внутри которого доступны статические поля класса – значит не выполнить статическую секцию инициализации нельзя. На экран выводится `"Hello1"`

Затем, прежде чем вызывается конструктор `StaticTest`, на экран выводится `"Hello3"`.

После этого вызывается конструктор, а вместе с ним и секция инициализации (они всегда выполняются в одно и то же время по очереди). На экран выводится `"Hello2"`.

> **Когда вызывается статическая секция инициализации?**
>
> Схематично говоря, когда класс "впервые загружается в память". Java может достаточно долго откладывать этот момент. Более того, некоторые операции, не затрагивающие содержимое класса (например, `class.getName()`) могут быть выполнены без необходимости выполнить статическую секцию инициализации. Поэтому, секция будет выполнена как только в этом появится необходимость.
>
> Статическая секция инициализации выполняется только один раз.

В секцию инициализации бывает полезно вынести общий код, который будет выполняться во всех конструкторах. Это сделает их более компактными.

> **В каком порядке выполняются секции инициализации и конструкторы?**
>
> Этот вопрос возникает вследствие того, что в Java разрешено иметь несколько секций инициализации. Помимо этого, в описании полей класса допустимы значения по умолчанию, которые тоже могут иметь вид каких-либо выражений, которые могут включать вызовы других методов.
>
> Коротко говоря, они выполняются в том порядке, в котором они написаны в коде.
>
> Здесь стоит отметить, что этот порядок могут нарушить делегирующие конструкторы или конструкторы, вызывающие (в том числе и неявно) конструктор базового класса
