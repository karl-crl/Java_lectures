# ООП и исключения

## Классы и ООП

Объявление класса начинается с ключевого слова `class`. Перед ним могут указаны модификаторы класса.

* Тело класса пишется в фигурных скобках.
> В отличие от C++, нельзя (вообще говоря, в Java в этом нет необходимости) писать объявление класса в одном файле, а определение – в другом.
* Классы хранятся в файлах с расширением `.java`. Если файл называется `ClassName.java`, то в нём обязательно должен находиться только один публичный класс, и его название должно совпадать с именем файла.
> Так как корректные идентификаторы в Java не ограничиваются таблицей ASCII, то можно создавать необычные имена классов или любых других идентификаторов. Например, класс `回国.java` компилируется безо всяких ограничений.
>
> Однако, скорее всего, IDE выдаст warning за использование символов не из ASCII в качестве идентификатора.
* Объявление полей синтаксически не отличается от объявления переменных (большинство ограничений носят семантический характер).
* Поля, не инициализированные явно, инициализируются значениями по умолчанию. То есть, нулём соответствующего типа для примитивов и `null` для ссылочных типов.
* `[modifiers] method_name(args) {body}`.

```java
// Файл ExampleClass.java

class ExampleClass {
    int value;

    int getValue() {
        return value;
    }
}
```

* В Java допускается создание нескольких методов с одинаковым именем, но разными типами аргументов. Это называется *перегрузка* (*overload*) методов (не путать с переопределением (*override*)).
> В зависимости от изученных ранее языков, может показаться: зачем это уточнять? В каких языках нет перегрузки функций или методов?
>
> В языках более низкого уровня. Например, C.

### Конструктор

Конструктор – особый метод класса. 
* Имя строго совпадает с именем класса, а возвращаемое значение отсутствует.
* Инициализирует созданный объект класса. Например, там можно следуя какой-то логике инициализировать поля класса или захватывать ресурсы, которыми будет владеть объект на протяжении его времени жизни.

**Важно!** После вызова конструктора объект класса должен находиться в согласованном состоянии (то есть, никакие инварианты не должны быть нарушены). Не соблюдение этого правила влечёт за собой возрастание сложности поддержки и использования класса в дельнейшем.

* Если не объявлен ни один конструктор, автоматически будет сгенерирован конструктор по умолчанию (без параметров).

* Конструктор можно вызвать, используя ключевое слово `new` следующим образом: `Pizza pizza = new Pizza("Hawaiian", 30);`. В отличие от C++, круглые скобки в конструкторе без параметров опускать запрещено – это приводит к ошибке компиляции.

* Конструктор не может быть `final` (ошибка компиляции). Можно сказать, что
любой конструктор уже является `final`. Если какой-нибудь наследник её
переопределит, то с инициализацией полей базового класса всё может быть
очень грустно. Поэтому в конструкторе наследника необходимо сначала
вызывать super конструктор. Также стоит заметить, что имя конструктора
жёстко задано именем класса, и у наследника имя конструктора будет другое.\

#### Делегирование конструкторов

Ситуация, когда один конструктор передаёт по цепочке вызов какому-то другому конструктору, возможно, уточнив параметры. С этой точки зрения конструктор ничем не отличается от метода: их также можно перегружать.

* У одного экземпляра класса конструктор может быть вызван только единожды. Поэтому, вызывать один конструктор из другого можно исключительно с помощью делегирования. Вот, как это выглядит:

```java
public class Color {
    private final String name;

    Color() {
        this("red"); // Делегирование конструктора
    }

    Color(String name) {
        this.name = name;
    }
}
```

Такая конструкция (вызов `this` с соответствующими параметрами) обязательно должна находиться на первой непустой строке в теле конструктора. Во всех остальных местах такая конструкция запрещена.

> Также, на этом примере можно увидеть один из вариантов задания значений полям по умолчанию: делегируя конструкторы с соответствующими значениями параметров.

### Деструктор

Коротко говоря, его нет.

Если разбираться более детально: в Java нет необходимости в наличии деструктора, так как сборка мусора осуществляется автоматически. Однако, только что говорилось про то, что в конструкторе можно захватить ресурсы – как их тогда освобождать?

Устаревшим методом является переопределить метод `void finalize()`, унаследованный от `java.lang.Object`. Сейчас этот метод deprecated. В виду того, как устроен сборщик мусора, у программиста отсутствует хоть какая-нибудь гарантия, когда метод `finalize` будет вызван. Гарантируется, что этот метод вызовется ровно один раз перед тем, как сборщик мусора уничтожит объект. Однако когда именно запустится сборщик мусора – не ясно. Более плохой ситуацией является, если из метода `finalize` "утечёт" ссылка на `this`. Компилятор не может это запретить, однако ни к чему хорошему это не приведёт.

 Собственно, это и послужило поводом запрещения к использованию этого метода и переосмысления дизайна концепции освобождения ресурсов.

> **Зачем это вообще может понадобиться?**
>
> Например, на некоторых ОС если не освободить дескриптор файла, в который только что производилась запись, произойдёт следующее:
> * Какой-то объём данных будет храниться в памяти, ожидая команды сброса содержимого буфера на диск
> * Приложение, которое производило запись в файл, завершается, перед этим не закрыв файловый дескриптор
> * Текущие изменения в буфере не будут сброшены на диск, а будут отвергнуты
>
> Есть более "современный" пример необходимости освобождения ресурсов. Пусть приложение в качестве ресурса создаёт подключение к некоторой маленькой базе данных. Если подключения создаются достаточно часто, а у базы данных есть ограничение на количество активных соединений, то в какой-то момент, если не освобождать ресурс "соединение с базой данных", она будет отказывать в создании новых подключений.

Современным способом является сделать так, чтобы класс реализовывал интерфейс `AutoCloseable`. Это добавит в публичный интерфейс класса метод `void close()`, в котором можно будет описать необходимую логику для освобождения ресурсов.

Помимо всего прочего, этот интерфейс также даёт следующие преимущества:

* Чтобы метод `close` был вызван автоматически, вызов захвата ресурсов классом можно сделать в секции [try-with-resources](#исключения-и-ресурсы);
* Сам факт, что класс реализует интерфейс `AutoCloseable` уже будет говорить программистам, которые будут с этим классом работать о том, что данный класс может захватывать какие-то ресурсы и требует вызова метода `close` для их освобождения

### Наследование

* В Java для наследования используется ключевое слово `extends`.
* Множественного наследования нет, справа от `extends` может быть указан только один класс.

На вершине иерархии наследования каждого класса находится `java.lang.Object`. Если у какого-то класса явно не указывается класс-родитель, значит этот класс всё равно неявно наследуется от `Object`.

Синтаксис:
```java
class HashMap extends AbstractMap {

}
```

Похожим на [делегирование конструкторов](#делегирование-конструкторов) синтаксисом обладает вызов родительских конструкторов. Единственное существенное отличие (помимо того, к конструктору какого класса идёт обращение) в том, что вместо ключевого слова `this` используется слово `super`. Также остаётся правило про то, что это выражение должно являться первым в теле конструктора.

### Интерфейсы

Интерфейс (в ООП в целом) определяет некоторый набор методов, который должны иметь все классы, реализующие этот интерфейс. В нём находятся объявления (сигнатура) методов, которые будут у всех классов, реализующих этот интерфейс. А задача самих этих классов – предоставить реализацию соответствующим методам.

В отличие от наследования, в Java допустима реализация сразу нескольких интерфейсов одним и тем же классом.

Интерфейс определяется подобно классу, только вместо ключевого слова `class` используется ключевое слово `interface`:

```java
interface Drawable {
    void draw();
}

class Player implements Drawable, Serializable {
    @Override
    public void draw() {
        // ...
    }
}
```

* В интерфейсе все методы по умолчанию имеют модификатор доступа `public`;
* Все поля в интерфейсе – `public static final`;
* С Java 8 стало возможным объявлять реализацию метода в интерфейсе по умолчанию с помощью ключевого слова `default`;
* С Java 8 в интерфейс стало позволено добавлять статические методы.

## Инициализация

### Инициализация переменных

* Переменные инициализировать обязательно.
При этом, объявление и инициализация могут быть двумя отдельными выражениями.
Главное, чтобы между ними ни в каком другом выражении не осуществлялся доступ
на чтение из неинициализированной переменной. В отличие от C++ это приведёт
к ошибке компиляции (в C++ такого поведения можно добиться, указав
соответствующий флаг при компиляции).

```java
int x; // Объявление
x = 1; // Инициализация
```

### Инициализация полей

* Поля можно оставлять "неинициализированными". Это приведёт к тому, что при
создании экземпляра класса (или в *другое* время, если поле статическое) поле
будет инициализированно нулём соответствующего типа для примитивов или
результатом вызова дефолтного конструктора для объектов.

```java
class Test {
    int n = 13;
    int i = foo(n);

    int foo(int num) {
        return num * num - 1;
    }
}
```

Этот пример говорит, что при инициализации полей можно вызывать методы класса (только статические методы, если поле статическое), а также обращаться к другим **уже инициализированным** полям.

### Секции инициализации

В Java существуют так называемые *секции инициализации* и *статические секции инициализации*. Они выглядят следующим образом:
**Типы секций инициализации**:
* Статическая (в значительной степени увеличивает функциональность программы
**???ПОЧЕМУ???**)
* Динамическая (просто удобно)

Важно помнить:
* Если блоков инициализации несколько, то они выполняются в порядке следования
в тексте класса.
* Инициализаторы переменных тоже выполняются в порядке следования.

```kotlin
class A {
    val x: String = run {
        print("1")
        "hello"
    }

    init {
        print("2")
    }

    val y = run {
        print("3")
        "world"
    }

    init {
        print("4")
    }
}

fun main() {
    val a = A()
    // prints 1234
}
```
* Блок инициализации может кидать исключение, если их объявления перечисленны
в предложениях `throws` всех конструкторов класса.
* Динамический блок полезен, если необходимо инициализировать поле анонимного
класса (в анонимном классе нельзя объявить конструктор)

**Во время загрузки класса порядок выглядит следующим образом:**
1) Определение статических полей родительских классов.
2) Инициализация статических полей и выполнение статических блоков родительских
классов.
3) Определение статических полей класса.
4) Инициализация статических полей, выполнение статических блоков класса.

**Затем при создании объекта, порядок выглядит следующим образом:**
1) Определение полей объекта из родительских классов.
2) Инициализация полей и выполнение динамических блоков из родительских классов.
3) Выполнение конструкторов из родительских классов.
4) Определение полей объекта из его класса.
5) Инициализация полей и выполнение динамических блоков из его класса.
6) Выполнение конструктора из его класса.

Пример:
```java
public class StaticTest {
    static int i;

    int j;
    int h;

    static { // Статическая секция инициализации
        i = 25;

        System.out.println("Hello1");
    }

    { // Секция инициализации
        j = 8;
        h = 3;

        System.out.println("Hello2");
    }

    public static void main(String[] args) {
        System.out.println("Hello3");

        StaticTest t = new StaticTest();
    }
}

// На экран будет выведено:
//  Hello1
//  Hello3
//  Hello2
```
* Сначала выполняется статическая секция инициализации, потому что вызывается
статический метод класса `StaticTest`, внутри которого доступны статические
поля класса – значит не выполнить статическую секцию инициализации нельзя.
* После этого вызывается конструктор, а вместе с ним и секция инициализации
(они всегда выполняются в одно и то же время по очереди).


> **Когда вызывается статическая секция инициализации?**
>
> Схематично говоря, когда класс "впервые загружается в память". Java может достаточно долго откладывать этот момент. Более того, некоторые операции, не затрагивающие содержимое класса (например, `class.getName()`) могут быть выполнены без необходимости выполнить статическую секцию инициализации. Поэтому, секция будет выполнена как только в этом появится необходимость.
>
> Статическая секция инициализации выполняется только один раз.

В секцию инициализации бывает полезно вынести общий код, который будет выполняться во всех конструкторах. Это сделает их более компактными.

> **В каком порядке выполняются секции инициализации и конструкторы?**
>
> Этот вопрос возникает вследствие того, что в Java разрешено иметь несколько секций инициализации. Помимо этого, в описании полей класса допустимы значения по умолчанию, которые тоже могут иметь вид каких-либо выражений, которые могут включать вызовы других методов.
>
> Коротко говоря, они выполняются в том порядке, в котором они написаны в коде.
>
> Здесь стоит отметить, что этот порядок могут нарушить делегирующие конструкторы или конструкторы, вызывающие (в том числе и неявно) конструктор базового класса

## Исключения

Исключением называют событие (или по-другому "исключительную ситуацию"),
которое прерывает нормальное исполнение работы программы. Необходимо уметь
понимать, к каким событиям программа "готова", а какие – являются
исключительными, и не путать их друг с другом. Более подробно этому аспекту
будет уделено внимание, когда пойдёт речь об
[управлении на исключениях](#как-не-стоит-делать-при-работе-с-исключениями).

Примеры исключений из стандартной библиотеки:

* `java.lang.NullPointerException` – то самое, знаменитое исключение. Возникает при попытке обратиться к полю объекта в то время, как в настоящий момент вместо ссылки на конкретный объект выражение возвращает `null`;
* `java.lang.ArrayIndexOutOfBoundsException` – исключение, возникающее при попытке обратиться по несуществующему индексу в массиве;
* `java.lang.ClassCastException` – исключение, возникающее при попытке преобразовать объект одного класса в объект другого, не совместимого класса;
* `java.lang.OutOfMemoryError` – исключение, возникающее, если JVM попыталась запросить память у ОС и получила отказ (учитывая флаг на ограничение памяти JVM при запуске приложения). Пытаться обработать такую ошибку в большинстве случаев не имеет смысла, потому что почти невозможно сделать что-то осмысленное.

* Все исключения в Java имеют базовый тип `Throwable`.
* Наследники делятся на исключения (`Exception`) и ошибки (`Error`).

Ошибки – это некоторые системные сбои, фатальные для программы в том смысле, что при их возникновении очень мала вероятность, что ошибку можно разумно обработать и продолжить работу. К таким относятся выше упомянутый `OutOfMemoryError` или, например, `java.lang.VirtualMachineError`.

Дальнейшее деление – одна из "визитных карточек" Java. Исключения делятся на *проверяемые* (*chacked*) и *непроверяемые* (*unchecked*). Все они являются наследниками класса `Exception`.

Непроверяемые исключения являются наследниками класса `RuntimeException`. Все остальные наследники класса `Exception` являются проверяемыми исключениями.

Почему они так называются? Кто их "проверяет"? Проверяемые исключения проверяются компилятором. А именно: если метод в ходе своей работы может породить какое-нибудь проверяемое исключение, он обязательно должен задекларировать это в своей сигнатуре с помощью ключевого слова `throws`. В противном случае, программа не будет компилироваться. Пример:

```java
class Example {
    public static void main(String[] args) throws IOException {
        // ...
    }
}
```

Если в каком-то методе будет вызван метод, способный породить проверяемое исключение, вызывающий метод должен либо его обработать, либо добавить в сигнатуру, что он тоже может бросать исключения такого типа (если в этом методе невозможно предпринять какие-нибудь осмысленные действия для перехвата исключения и восстановления корректной работы программы).

Непроверяемые исключения чаще связаны с ошибками программирования или с неправильным взаимодействием с каким-нибудь API. Например, было бы заметно труднее писать код, если бы `NullPointerException` был проверяемым исключением. Проверяемые исключения, в свою очередь, довольно часто встречаются при взаимодействии внешними ресурсами (особенно если это IO).

> Гораздо реже встречают `NullPointerException` программисты на Kotlin, потому что дизайн языка предоставляет удобную работу с null-safe операторами.

### `java.lang.Throwable`

`Throwable` – это базовый класс для всех исключений. Благодаря ему, у них всех есть некоторый общий интерфейс, а именно:

* `String getMessage()` и `String getLocalizedMessage()` – методы для получения сообщения об ошибке в виде строки. Второй из перечисленных методов, при этом, пытается учитывать настройки локализации и возвращать текст сообщения об ошибке на языке, соответствующем установленной локали;
* `Throwable getCause()` – иногда одно исключение может послужить причиной для возникновения другого исключения (пример можно будет встретить в секции [try-with-resources](#исключения-и-ресурсы)). Данный метод позволяет получить исключение, которое послужило причиной возникновения данного. В случае, если такого нет, метод возвращает `null`;
* `void printStackTrace()` – выводит трассировку стека (stack trace)  в момент возникновения исключения в системный поток ошибок. Это диагностическая информация, которая может помочь в отладке программы.

### Как самостоятельно сгенерировать исключение?

Для этого в Java есть специальный оператор `throw`. В качестве аргумента ему нужно передать созданный объект-наследник `Throwable` (не обязательно прямой наследник). Это – серьёзное отличие от C++, где можно бросать любой тип данных, например, числа. Выглядит это следующим образом:

```java
import java.io.File;

class Example {
    public static void main(String[] args) throws IOException {
        File input = new File("path/to/file.txt");

        // ...
    }
}
```

Данный оператор прерывает нормальный поток исполнения программы и запускает поиск обработчика исключения вверх по стеку. Ситуация, когда соответствующего обработчика не нашлось ни в одной функции, включая точку входа программы, приводит к её аварийному завершению.

### Как перехватить исключение?

Для этого существует специальная языковая конструкция `try .. catch`. Идея следующая: в блоке `try` пишется код, который потенциально генерирует исключения. В блоке `catch` необходимо указать, какие исключения программа ожидает в блоке `try`, и что нужно предпринять для их обработки. Блоков `catch` может быть несколько, чтобы по-разному обработать разные возникающие исключения. Пример:

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

class Example {
    public static void main(String[] args) {
        try {
            File input = new File("path/to/file.txt");
            Scanner scanner = new Scanner(input);
        } catch (FileNotFoundException e) {
            File error = new File("error.txt");
            error.createNewFile();
        }
    }
}
```

Стоит заметить, что поиск обработчика исключения, про который говорилось в [предыдущем](#как-самостоятельно-сгенерировать-исключение) ищет как раз блок `catch`, который способен обработать возникшее исключение. Способен обработать он его только тогда, когда его ожидаемый класс исключений – совпадает или является родительским для класса возникшего исключения.

Дальнейшее исполнение программы продолжается после блока `catch`, в котором исключение было обработано.

С Java 7 появилась следующая возможность: если для нескольких разных типов исключений совпадает их код обработки, то их можно объединить в один следующим образом:

```java
try {
    // ...
} catch (FileNotFoundException | SocketException e) {
    e.printStackTrace();
}
```

> **Стратегии обработки исключений**
>
> При перехвате исключения его необходимо как-то _содержательно_ обработать. Большое внимание нужно уделить именно тому, чтобы это было содержательно.
>
> Так, например, дурным тоном является оставлять пустой блок `catch` только для того, чтобы не тянуть длинную цепочку из `throws` через функции. Это плохо, потому что при возникновении исключения никто об этом не узнает. И если это приведёт к ошибкам в программе, то их будет труднее найти.
>
> Ещё один не самый хороший вариант обработки исключений: запись в лог. Если в обработчике кроме этого ничего не делается, то в целом – это то же самое, что и предыдущий пункт, только при этом у программистов будут варианты, где искать ошибку. Однако, это не спасает от главной проблемы: работа программы продолжится в, возможно, некорректном состоянии.
>
> Поэтому, если в данной функции не получается содержательно обработать исключение, его можно пробросить дальше (либо явно вызвав `throw`, либо отсутствие блока `catch`, способного обработать возникшее исключение конкретного типа, приведёт к его пробросу вверх по стеку).
>
> В некоторых случаях бывает полезно обернуть исключение в другое. Это практически аналогично его простому пробросу. Может применяться, например, в случаях, если у функции фиксирована сигнатура, и ей запрещено выбрасывать исключения других типов.
>
> Самый удачный вариант – если в блоке `catch` удаётся совершить что-нибудь полезное. Например, при ошибке передачи данных по сети там можно инициировать повторный запрос через некоторый интервал времени.

### **Исключения и ресурсы**

В конструкции `try .. catch` также имеется третий блок: `finally`. Этот блок выполняется в любом случае: независимо от того, сумел ли `catch` перехватить исключение.

Часто его используют для того, чтобы освободить захваченные ресурсы. Например:

```java
InputStream is = new FileInputStream("file.txt");

try {
    read(is);
} finally {
    is.close();
}
```

В отличие от блока `catch`, блок `finally` в такой конструкции может быть только один.

Это довольно распространённый паттерн, поэтому для ресурсов, требующих вызова метода `close` по окончании их использования, в Java 7 добавили следующую синтаксическую конструкцию, называемую **try-with-resources**. Она выглядит следующим образом:

```java
try (InputStream is = new FileInputStream("file.txt")) {
    read(is);
}
```

Её особенность в том, что метод `close` у всех ресурсов, захваченных в блоке `try`, вызывается автоматически. Помимо этого, в круглых скобках можно указывать несколько ресурсов, разделяя их с помощью `;`.

Для того, чтобы ресурсы поддерживали использование в такой конструкции, они должны реализовывать интефейс `AutoCloseable`, который добавляет в их публичный интерфейс метод `close`.

Начиная с Java 9, в секции захвата ресурсов допустимо указывать `final` или *effectievly final* переменные.

#### Возможная реализация try-with-resources

```java
OutputStream stream = openOutputStream();
Throwable mainThrowable = null;

try {
    // что-то делаем со stream
} catch (Throwable t) {
    // сохраняем исключение
    mainThrowable = t;
    // и тут же выбрасываем его
    throw t;
} finally {
     if (mainThrowable == null) {
         // основного исключения не было. Просто вызываем close()
         stream.close();
     }
     else {
         try {
            stream.close();
         } catch (Throwable unused) {
             // игнорируем, так как есть основное исключение
             // можно добавить лог исключения (по желанию)
         }
     }
}
```

Код взят со [статьи на Хабре](https://habr.com/ru/post/178405/).

## Применение исключений в коде

* Ошибки стоит обрабатывать там, где для этого есть достаточно информации. То есть, если всё, что получается сделать в этой функции – это записать в лог, то исключение лучше пробросить наверх;
* Нужно обращать внимание, и при работе с ресурсами не завбывать освобождать их. К счастью, в этом сильно помогает конструкция try-with-resouces.

### Как не стоит делать при работе с исключениями

* Не стоит использовать исключения для работы с не-исключительными ситуациями. Например, очень плохой идеей является с помощью исключений передавать какую-нибудь информацию, на которой будет завязана какая-нибудь логика в коде. Для этих целей существуют функции и возврат значения из них. Более того, в пользу этого говорит тот факт, что когда исключения в программе довольно редкие, JVM очень эффективно (по скорости) может их обработать. Если их начинает быть слишком много, это катастрофически бьёт по производительности
* Не рекомендуется перехватывать базовые классы исключений типа `Exception` или даже `Throwable`. Факт возникновения такого исключения не даст никакой информации о том, как именно можно его обраьотать, потому что даже не ясно, что вообще произошло.

### Как написать своё исключение?

Это довольно просто. Нужно унаследоваться от какого-нибудь из стандартных классов исключений. В общем случае от `Exception`, если исключение должно быть проверяемым и от `RuntimeError`, если исключение должно быть непроверяемым.

```java
public class GitException extends Exception {
    public GitException(String message) {
        super(message);
    }

    public GitException(Throwable cause) {
        super(cause);
    }

    public GitException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

Также рекомендуется унаследовать несколько конструкторов для удобства создания исключений. Часто полезными оказываются конструктор от строки и конструктор, принимающий на вход исключение-причину (cause). Пример использования:

```java
try {
    // ...
} catch (IOException e) {
    throw new GitIOException(e);
}
```

В данном примере из функции бросается пользовательское исключение `GitIOException`, которое содержит информацию о том, что оно было вызвано пойманным `IOException e`.

Выбор, заключающийся в том, делать ли проверяемое или непроверяемое исключение, основывается на следующем: если пользователь сможет содержательно его обработать, то оно должно быть проверяемым, в противном случае – непроверяемым.
