`java.util.concurrent` - дополнительные фичи.

* Не все написано на java (много на нативном языке)

А зачем?
1. Нет возможности проверить, занят ресурс или нет.
2. 

Почему не можем просто добавить это в `synchronized`?

Методы блокировки

* `newCondition()` - у `Lock` можно порождать новые условия.

## Условия:
Интерфейс `Condition`
* `await(time?)` - ждать условие
* `awaitUntil(deadline)` - ждать до
* `awaitUninterruptibly()`
* `signal()` - аналог `notify()`
* `signalAll()` - аналог `notifyAll()`

Пример про производителя.
```java
while(this.data != null)
```


**ВАЖНО**: всегда надо отпускать блокировку
```kotlin
lock.lock()
try {
    // тут может быть вообще все что угодно
} finally {
    lock.unlock()
}
```

# Читатели-писатели

# Управление заданиями
## Исполнители

Много потоков => очень много времени уходит на переключение в планировщике потоков.
Поэтому делают пул потоков.

**Интерфейс `Executor`**
* `execute(Runnable)` - выполнить задание.

Возможные варианты выполнения:
* В том же потоке
* В новом потоке
* Пул потоков
* Наращиваемый пул потоков

Функции и результаты
* Интерфейс `Callable<V>` - функция
* * `V call()` - посчитать функцию
* Интерфейс `Future<V>` - результат (контейнер, в котором когда-нибудь, появится
результат выполнения `Callable`)
* * `get(timeout?)`
* * `isDone()`
* * `cancel()`


