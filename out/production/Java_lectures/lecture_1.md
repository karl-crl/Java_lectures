## JVM

Вопросы и дополнения:
* Как работает разогрев JVM
* 

(NB: Часть информации взята с АУшного конспекта по Java)

JVM - ПО, которое выполняет код и предоставляет среду для выполнения кода.   
JVM = Интерпретатор + JIT + GC.  
Код компилируется в байт-код, байт-код интерпретируется JVM.

**Что делает JVM?**
* Интерпретирует байт-код => кросс-платформенность.
* Сама управляет памятью (ура, гораздо меньше способов прострелить себе колено).
Необходимо только вручную выделять память, освобождает память JVM. Так же
 не ломает ОС. Например, захотел по какому-то адресу достать, например,
 строчку, а там просто чиселка, и всё ломается. JVM же сама это всё отследит
 и не допустит подобной ситуации. А если программист попытается скастовать,
 например, ArrayList к String, то она это отследит и выдаст красивый и
 аккуратный exception, с которым можно удобно работать.
* В JVM чаще всего есть JIT (just in time компиляция), которая умеет делать много полезных плюшек:
    * ????
 
**Управление памятью**:

JVM сама выделяет (по запросу) и освобождает память. Удаляет объекты, которые недостижимы со стеков (м.б. несколько потоков)
и из статической памяти.

## Некоторый синтаксис

Есть жестко закрепленные и принятые соглашения по code style: code conventions.
Те, кто их не соблюдают, горят в аду.
* Названия всех классов с большой буквы (и CamelCase).
* Все функции, методы и поля с маленькой буквы.
* Названия всех констант с большой буквы и разделяются подчеркиваниями.
* `this`  пишется только там, где необходимо для компиляции.

Некоторая важная информация:
* В программе должен быть класс, у которого есть метод 
```
public static void main(String[] args)
```
`public` - чтобы мог кто угодно вызывать функцию.   
`static` - чтобы можно было запустить вне класса.
* Порядок вычислений аргументов функции определен! Слева направо.
* В отличие от C++, где массив - это просто какой-то кусок памяти, в Java массив - это объект,
который имеет длину, чтобы можно было ее узнать и не вылезти за границы массива.
* В Java есть package - похоже на namespace. Принято, чтобы классы находились внутри пакетов.
* По-умолчанию все методы `package private`.

## Модификаторы
Всего 4 модификатора доступа:
* public (видно все и отовсюду)
* protected ()
* package private (по-умолчанию)
* private

Кроме этого есть еще ряд модификаторов:
- модификатор static применяется для создания статических методов и переменных класса;
- модификатор final используется для завершения реализации классов, методов и переменных;
- модификатор abstract необходим для создания абстрактных классов и методов;
- модификаторы synchronized и volatile используются в Java для потоков;
- есть еще, но их пока не проходили.

### Модификатор final

**Переменные**:
* Переменная c `final` может быть инициализирована только 1 раз.
* Они не инициализируются с final может быть по умолчанию, инициализирована необходимо только явно один присвоить
значение при объявлении или в конструкторе, иначе – ошибка компиляции.
* Ссылочная переменная, объявленная как final, никогда не может быть назначена для обозначения другого
объекта. Однако поля объекта могут быть изменены. Также это справедливо и для массивов, потому
что массивы являются объектами: массив может быть изменен, но переменная всегда будет ссылаться
на тот же самый массив.  
`final` переменная =  ссылка в C++.
* С переменными модификатор final часто используется совместно со static, чтобы сделать переменную
класса константой. Подобные переменные должны быть инициализированы во время объявления или в
статическом блоке.  
`final static = const`.


* Метод c `final` не может быть переопределен. Аргументы методов, обозначенные
 как `final`, предназначены только для чтения, при попытке изменения будет
 ошибка компиляции.
* Абстрактный класс не может создать экземпляр. Если класс объявлен
как abstract, то единственная цель для него - быть расширенным
через наследование. Класс не может быть одновременно `abstract` и `final`,
так как класс с модификатором final не может быть расширенным.
* От класса с final нельзя наследоваться. Поэтому все его методы не могут
быть переопределены и неявно также становятся финальными.
* Абстрактные методы тоже не могут быть `final`.
* `private` методы неявно являются `final`. `final` блокирует метод от переопределения
в классах наследниках. `private` метод и так не может быть переопределен в
наследниках, т.к. он там недоступен.
* Конструктор не может быть `final` (ошибка компиляции). Можно сказать, что
любой конструктор уже является `final`. Если какой-нибудь наследник её
переопределит, то с инициализацией полей базового класса всё может быть
очень грустно. Поэтому в конструкторе наследника необходимо сначала
вызывать super конструктор. Также стоит заметить, что имя конструктора
жёстко задано именем класса, и у наследника имя конструктора будет другое.
* Если у класса лишь 1 конструктор, он не может быть `final` или `private`
(ошибка компиляции).
