# Примитивные и ссылочные типы в Java

## Примитивные типы

Размер типа фиксирован спецификацией языка.

| Тип       | Размер (байт) | Класс-обёртка |
|-----------|:-------------:|---------------|
| `void`    |       0       | `Void`        |
| `boolean` |     1 бит     | `Boolean`     |
| `char`    |       2       | `Character`   |
| `byte`    |       1       | `Byte`        |
| `short`   |       2       | `Short`       |
| `int`     |       4       | `Integer`     |
| `long`    |       8       | `Long`        |
| `float`    |       4       | `Float`       |
| `double`  |       8       | `Double`      |

``Особенности``:

* `boolean` занимает 1 бит. 8 разных переменных типа `boolean` могут
храниться в одной 8-битной ячейке памяти, тем самым занимая по 1 биту каждая.
Это зависит от реализации JVM (может занимать столько, и сколько `int`).
Единственный примитивный тип, для которого не определён строго размер.

Примитивные типы можно разделить на
- целочисленные,
- нецелочисленные,
- символьный тип `char`,
- логический тип `boolean`,
- пустой тип `void`.

> Примитивные типы передаются по значению. Что это значит?
>
> Это значит, что выражение `x = y`, где `x` и `y` имеют какой-нибудь примитивный тип (для определённости пусть это будет `int`) приведёт к тому, что значение переменной `y` будет скопировано в переменную `x`.
>
> Если после этого, например, вызвать оператор инкремента у переменной `x`: `x++`, то значение `y` останется прежним, так как оно было скопировано.
>
> Пример:
> ```java
> int x = 4;
> int y = 2;
> x = y;
> x++;
> // x == 3, y == 2
> ```
 
## Ссылочные типы

Все остальные типы, кроме перечисленных выше, являются ссылочными.

> Часто говорят, что "ссылка" сама по себе является особым примитивным типом. 
>
>Действительно, если рассматривать любую переменную ссылочного типа как переменную, хранящую некий адрес в памяти, с которым особенным образом умеет обращаться Java, то такая переменная – которая просто хранит целое число – будет являться переменной примтивного типа.

Передача значения по ссылке позволяет двум переменным указывать на один
объект. изменение этого объекта в одной переменной приведёт к его изменению
в другой.

Пример:
```java
Book book = new Book("The Gold-Hatted Gatsby");
Book favouriteBook = book;

book.setTitle("The Great Gatsby");
// book.title == "The Great Gatsby"
// favouriteBook.title == "The Great Gatsby"
```

`null` - отсутствие текущего значения у переменной ссылочного типа.
Его можно присвоить любой переменной, имеющей ссылочный тип.

Любая ссылочная переменная по умолчанию инициализирована значением `null`.
```java
String x;
// x == null
```

### `java.lang.Object` 

Любая переменная ссылочного типа на вершине иерархии наследования имеет
класс `Object`.

> `null` не является объектом ссылочного типа, и как следствие, не наследуется от `Object`. Строго говоря, `null` вообще не является объектом.

У всех объектов можно вызвать (или переопределить) методы, определённые в
`Object` (т.к. любой объект от него наследуется).

Неполный список этих методов:
* `String toString()` – приводит объект к строке.
Реализация по-умолчанию: возвращает имя класса и некоторое число
(можно думать, как об адресе объекта в памяти). 
> У некоторых классов ртной библиотеки (например, `ArrayList` или `Map.Entry`) этот метод переопределён для того, чтобы возвращать более информативное строковое представление объекта
* `int hashCode()` – хеш-код объекта.
> Он используется, в объектах/алгоритмах типа `HashMap`. Иногда его
> используют как fast-pass для реализации equals: можно сразу отсечь часть
> объектов, которые точно не равны. Имеет смысл для иммутабельных коллекций,
> у которых хеш можно закешировать.    
> Хеш код по-умолчанию вычисляется с помощью функции System.identityHashCode
> Она вычисляет его, основываясь на адресе объекта в памяти.    
> Чтобы стандартный хеш не изменялся после перемещения объектов
> сборщиком мусора, у всех объектов, у которых hashCode не переопределён,
> jvm создаёт дополнительное поле для сохранения хэша,
> вычисленного при первом обращении к hashCode. При дальнейших вызовах она
> просто возвращает это значение.

 #### Контракт между `equals()` и `hashCode()`

Если метод `a.equals(b)` вернул `true`, то хеш-коды `a.hashCode()` и
`b.hashCode()` должны совпадать.

> Реализации некоторых алгоритмов и структур данных (например, `HashMap`) полагаются на выполнение этого инварианта. В противном случае не гарантируется их корректная работа.

#### В чём разница между `a.equals(b)` и `a == b`?

* `a == b` проверяет равенство ссылок (указывают ли обе эти переменные на
один и тот же объект в памяти). 

```java
Book firstBook = new Book("1984");
Book secondBook = new Book("1984");

firstBook == secondBook // false


Book book = firstBook;

firstBook == book; // true
```

* `a.equals(b)` проверяет равенство объектов по содержимому. 
Дефолтная реализация метода `equals()` в `Object` - проверка равенства ссылок.

## `boolean`

`boolean` является типом данных для логических значений в Java.
Переменные такого типа могут принимать значения `true` или `false`.

> Всего в Java есть шесть операторов сравнения: `>`, `>=`, `<`, `<=`, `==`, `!=`

Есть одна особенность, которая сильно отличает Java от, например, C++ и подобных языков, в которых есть эта возможность. В Java нет неявного приведения к логическому типу. То есть, для того, чтобы проверить, равняется ли нулю целочисленная переменная, недостаточно поместить её в условие оператора `if`: обязательно вызвать операцию явного сравнения с нулём.

| Нельзя                          |                   Можно                |
|---------------------------------|----------------------------------------|
| ```java int x = 10; if (x) {}``` | ```java int x = 10; if (x != 0) {} ``` |

Помимо операторов сравнения, в Java также есть ещё несколько операторов, возвращающих `boolean`. Это так называемые логические операции.

| Операция             | Оператор |
|----------------------|:--------:|
| Логическое "и"       |   `&&`   |
| Логическое "или"     | `||`     |
| Исключающее или      | `^`      |
| Логическое отрицание | `!`      |

Для первых трёх операторов существует также их разновидность, совмещённая с оператором присваивания, а именно: `&=`, `|=` и `^=`. Они работают (на примере логического "и") по следующей схеме:

```java
boolean a, b;

a = (boolean)(a && b);
// Снизу – сокращённая запись выражения сверху
a &= b;
```

Объяснение, откуда появился `(boolean)` и что это значит, будет рассмотрено в разделе про [преобразование типов](#Преобразование-типов)

### Вычисление по сокращённой схеме

Существует два варианта операторов логического "и" и "или". Для "и" это `&` и `&&`, а для "или" – `|` и `||`. В чём между ними разница?

Как известно из алгебры логики, выражение, состоящее из цепочки подвыражений, связанных логическим "и", ложно тогда, когда хотя бы одно из подвыражений ложно. В Java тоже есть такая возможность: при использовании операторов вычисления по сокращённой схеме (они состоят из двух символов: `&&` и `||`) в качестве результата выражения сразу вернётся `false` как только одно из подвыражений в цепочке, связанной оператором `&&`, будет вычислено как ложное.

С этим нужно обходиться осторожно. Так, например, при соответствующих условиях не будут вычислены выражения даже имеющие побочные эффекты. Например, если в выражении `foo() && bar() && baz()` функция `foo()` вернёт `false`, а остальные функции при вызове должны были напечатать что-то на экран, на экран не будет выведено ничего.

### `java.lang.Boolean`

У класса-обёртки `Boolean` есть несколько удобных функций.

Например, есть метод `boolean parseBoolean(String)`, который по строке определяет, какой логический литерал кодирует эта строка. Вообще говоря, этот метод возвращает `true` исключительно в том случае, если передпнная на вход строка в точности равна `"true"`.

Также, чтобы избежать лишних выделений памяти, когда в этом нет необходимости, класс `Boolean` предоставляет две статические константы: `Boolean.TRUE` и `Boolean.FALSE`. Так, например, большинство IDE будет выдавать предупреждение, если напрямую вызвать `new Boolean(true)`, потому что можно было бы использовать статическую константу.

## `char`

Представителем символьного типа в языке Java является тип `char`. Переменные такого типа могут хранить символы в кодировке Unicode.

Стоит отметить, что выражение типа `char` можно неявно привести к любому (кроме `byte`, так как у него меньше размер) целочисленному типу.

### Как можно задавать значения типа `char`?

Во-первых, существуют символные литералы. Это символ Unicode, заключённый в одинарные кавычки: `'F'`.

Помимо этого символ можно задавать с помощью его шестнадцатиричного кода (полезно, например, для непечатаемых символов – управляющих последовательностей из начала таблицы ASCII или для специальных символов, с помощью которых можно настроить задать текста в терминале): `'\u263a'`.

Последним способом является задание некоторых спецпоследовательностей, распознаваемых языком. Перечислим их в таблице ниже:

| Последовательность |                      Описание                      |
|--------------------|:--------------------------------------------------:|
| `\t`               |                  Символ табуляции                  |
| `\b`               | Символ backspace: удаление одного символа в строке |
| `\n`               | Символ перехода на новую строку                    |
| `\r`               | Символ возврата каретки                            |
| `\f`               | Символ "смены страницы" (form feed)                |
| `\'`               | Символ одинарной кавычки                           |
| `\"`               | Символ двойной кавычки                             |
| `\\`               | Символ одной обратной косой черты `\`              |

### `java.lang.Character`

У класса `Character` есть несколько статических методов (весьма полезных, например, при посимвольном парсинге данных), которые определяют, к какому классу принадлежит переданный аргументом символ. К таким методам относятся:

* `boolean isLowerCase(char x)`
* `boolean isUpperCase(char x)`
* `boolean isDigit(char x)`
* `boolean isWhiteSpace(char x)`
* `boolean isLetter(char x)`

Помимо этого также есть методы для конвертации символа в верхний и нижний регистр:

* `char toUpperCase(char x)`
* `char toLowerCase(char x)`

Ещё можно отметить наличие методов `int digit(char ch, int radix)` и обратного к нему `char forDigit(int digit, int radix)`. Они позволяют получить число, которому соответствует символ в указанной системе счисления и наоборот: по числу и системе счисления позволяет вернуть символ, которым это число будет кодироваться.

Это далеко не полный список методов этого класса, всего у него в публичном интерфейсе порядка 90 методов и много разных статических констант.

## Целочисленные типы

Серьёзным отличием от C++ является то, что размер всех целочисленных типов зафиксирован стандартом и не зависит от конкретной реализации JVM. Конкретные размеры типов данных приведены в таблице в начале главы.

### Как можно задавать значения целочисленных типов?

Для этого существует несколько различных вариантов. Самый простой – задать число в его десятичном представлении. Однако, числовые литералы можно представлять и в других системах счисления!

Чтобы задать числовой литерал в восьмеричной системе счисления, необходимо в качестве первого символа указать `0` (например: `int x = 016` задаст число 14, записанное в восьмеричной системе счисления).

Чтобы задать в шестнадцатиричной системе счисления – нужно указать префикс `0x` (например: `int x = 0xf1` задаст число 241, записанное в шестнадцатиричной системе счисления).

Начиная с Java 7, появился ещё один вариант записи целочисленных литералов. Теперь число можно задать и в двоичной системе счисления, для чего указывается префикс `0b` (например: `int x = 0b110` задаст число 6, записанное в довичной системе счисления).

Помимо представления в разных системах счисления, существуют ещё некоторые способы записи целочисленных литералов. Так, для того, чтобы задать литерал типа `long`, необходимо добавить суффикс `L` к записи числа (в любой из перечисленных выше систем счисления). Так, например, можно уберечь себя от ошибки, когда по неосторожности присваивается литерал, имеющий тип `long` в переменную типа `int`.

> Начиная с Java 7, в записи числа допустимы нижние подчёркивания. Этим можно пользоваться, например, для визуальной группировки разрадов числа, что значительно упрощает его чтение человеком. Сравните, насколько быстро получится понять порядок следующих двух чисел: `long x = 1000000000;` и `long y = 1_000_000_000;`.

### Арифметические операции

Все целочисленные типы поддерживают стандартный набор арифметических операций: сложение, вычитание, умножение, деление и взятие остатка от деления. Для каждой из этих операций существует соответствующий арифметический оператор, а также оператор, совмещённый с присваиванием.

Помимо них переменные целочисленного типа данных поддерживают операцию (как префиксного, так и постфиксного) инкремента и декремента (`++` и `--`).

При делении **целого числа** на ноль, бросается исключение `ArithmeticException`. (Акцент на следующем: для чисел с плавающей точкой деление на ноль имеет другое поведение, которое не приводит к возникновению исключения)

Переполнение (в отличие от C++) не является неопределённым поведением. При переполнении просто отбрасываются старшие биты получившегося числа. Для сравнения в C++ такое поведение гарантируется для беззнаковых чисел, а для чисел со знаком оно не определено.

### Классы-обёртки

Из примечательного в классах-обёртках можно выделить наличие статических полей, содержащих минимальное и максимальное возможное значение соответствующего типа. Например, `java.lang.Integer.MAX_VALUE` и `java.lang.Integer.MIN_VALUE`.

Также в них есть методы для безопасной конвертации значений в числа с плавающей точкой (`double doubleValue()`), парсинга числа из строки (`int parseInteger(String s, int radix)`) и многие другие.

> **А что с беззнаковыми числами?**
>
> До Java 8 их просто не было. Совсем 🙂.
>
> С Java 8 был расширен интерфейс классов-обёрток над целочисленными типами: туда добавили операции, которые позволяют работать с содержимым класса как с беззнаковым целым числом. К числу таких методов, например, относится `int divideUnsigned(int a, int b)`, который интерпретирует числа `a` и `b` как беззнаковые целые, и вернёт резальтат деления `a` на `b`.

## Типы данных для чисел с плавающей точкой

Чтобы задать такое число, можно с помощью точки показать, в каком месте заканчивается целая часть числа и начинается дробная. Помимо этого существует также экспоненциальная запись числа (ещё называемая *scientific notation*): `314.15e-2` означает `314.15 * 10^{-2}`.

Вещественные числа также можно записывать и в шестнадцатиричной системе счисления (однако, только в экспоненциальной записи). Для этого у  числа указывается `0x` в качестве префикса, а экспонена обозначается символом `p`: `0xDEADpBE` означает `DEAD * 2^BE`.

Для вещественных литералов также есть суффиксы, обозначающие принадлежность к конкретному типу данных: `f` для `float` и `d` для `double`. 

По умолчанию все вещественные литералы имеют тип `double`. Не знание этого факта может привести к непониманию, почему компилятор Java отказывается компилировать следующий код: `float x = 2.0;`.

### Деление на 0 и прочие особые случаи

В отличие от целых чисел, деление на 0 вещественного числа не приводит к возникновению ошибки. Для вещественных чисел определены специальные значения: бесконечность (`Double.POSITIVE_INFINITY`) и NaN (`Double.NaN`).

Как подсказывает название, бесконечность может иметь положительный или отрицательный знак. Собственно, результатом деления на ноль является бесконечность с таким же знаком, как у делимого.

Переполнение при операциях с плавающей точкой также возвращает бесконечность в качестве результата операции.

При делении нуля на ноль возвращается NaN, так как в математике результат такой операции не определён.

> При любой операции с NaN результатом является NaN. Такое явление называется *NaN-propagation*.
>
> Это довольно просто объяснить, если посмотреть, как устроено значение NaN в памяти. По стандарту IEEE-754 (ему соответствуют типы `float` и `double` в Java) NaN представляется как число, у которое все биты порядка равны единице, а биты мантиссы равны чему угодно, кроме нуля одновременно (потому что таким образом представляется бесконечность). 
>
> Тогда действительно не сложно представить, что все операции, которые не изменят порядок, приведут к тому, что в результате этой операции снова получится NaN. Если же операция меняет порядок.. то так как нельзя с уверенностью сказать, какое число участвовало в операции на месте NaN, можно заменить порядок результата операции на все единичные биты и гарантировать, что в результате этой операции не вернулось какое-то "мусорное" число.

## Преобразование типов

- Явное
- Неявное
> Дизайн языка Java предполагает сведение к минимуму неявных преобразований
> (о чём, например, говорит отсутствие неявного преобразования в `boolean`).

Строка - "из"  
Столбец - "в"  
``+`` - неявное преобразование.
, т.е.
```java
byte a = 2;
int b = a
```
``+-`` - можно сделать явное преобразование.
```java
int b = 300000;
byte a = b; # ошибка компиляции
byte a = (byte) b;
```

``-`` - нельзя делать преобразование

|         | byte | short | char | int | long | float | double | boolean |
|---------|------|-------|------|-----|------|-------|--------|---------|
| byte    |   +  |   +   |  +-  |  +  |   +  |   +   |    +   |    -    |
| short   |   +  |   +   |  +-  |  +  |   +  |   +   |    +   |    -    |
| char    |  +-  |   +-  |   +  |  +  |   +  |   +   |    +   |    -    |
| int     |  +-  |   +-  |  +-  |  +  |   +  |   +   |    +   |    -    |
| long    |  +-  |   +-  |  +-  |  +- |   +  |   +   |    +   |    -    |
| float   |  +-  |   +-  |  +-  |  +- |  +-  |   +   |    +   |    -    |
| double  |  +-  |   +-  |  +-  |  +- |  +-  |   +-  |    +   |    -    |
| boolean |   -  |   -   |   -  |  -  |   -  |   -   |    -   |    +    |

``Важно помнить``:
- Может произойти потеря значений (усекается до ПРАВЫХ N разрядов (где N -
  максимальное количество разрядов для данного типа)).

### Неявные преобразования

Примитивы можно приводить к любому целочисленному типу с большим
или равным размером. Такой тип преобразования называется *widening conversion*.
#### Автоматическое расширение

Особый случай неявного приведения типов. Происходит при операциях с
несколькими выражениями различных типов данных. Все операнды в выражении
нужно привести к общему типу.
> Можно считать этот общий тип наименьшим из достаточно широких типов
>(чтобы в нём можно было с минимальными потерями точно выразить каждый из
>операндов).

Применяются следующие правила:

* Если одно из выражений имеет тип `double`, общий тип выводится как `double` (никакие другие типы не могут представить любое число из `double` без серьёзных потерб точности. И наоборот: любой численный тип представим в `double` с незначительной потерей точности)
* Если одно из выражений имеет тип `float`, тип выводится во `float`
* Если одно из выражений – `long`, выводится `long`
* Если одно из выражений – `int`, выводится `int`.

``Важно:`` если не выполнено ни одно из перечисленных выше правил, то вывод
типа выполнен не будет.
 
> Рассмотрим следующий код:
>
> ```java
> char x = 'a';
> char y = 'a';
> char z = x + y;  # Ошибка компиляции
> char z = (char) (x + y); # Необходимо сделать явное преобразование
> ```

### Явные преобразования

Для явного приведения типов существуют специальные операторы. В скобках
перед выражением указывается тип данных, к которому необходимо
привести выражение. Например `(int)(10.0 - 5.8)`.

*  При приведении к типу меньшей размерности старшие биты результата
выражения отбрасываются;
* При приведении вещественного типа к целому отбрасывается дробная часть;
* Если вещественное число имело слишком большое значение,
то приведение даст `MIN_VALUE` или `MAX_VALUE`;
* При приведении слишком большого `double` к `float` результатом выражения
будет `INF` с соответствующим знаком.

> "Неявное явное преобразование"
>
> При использовании оператора, совмещённого с присваиванием, компилятор неявно подставляет оператор явного приведения типа перед получившимся выражением. Почему?
> 
> Потому что в такой записи пользователь может взаимодействовать только с правым операндом получившегося выражения в то время, как несовместимый тип может получиться после применения оператора. Поэтому, чтобы не создавать безвыходных ситуаций, компилятор подставляет в итоговое выражение оператор приведения типа.
>
> Стоит отметить, что такое поведение приведёт к приведению типа, даже если это будет сопровождаться потерей точности. Пример:
>
> ```java
> int x = 40;
> x += 2.0; // В то время, как прямое присваивание x = 42.0 не скомпилируется из-за несоответствия типов
> ```

## Boxing и unboxing

Примитивные типы могут свободно неявно преобразовываться в соответствующие типы-обёртки и обратно. Процесс преобразования примитивного типа в тип-обёртку называется *boxing*, а обратный процесс – *unboxing*.

### `Integer` pool

В целях оптимизации (очень похожим образом, как это сделано в Python) в JVM существует так называемый пул `Integer`-ов. В нём находятся заранее созданные 256 объектов типа `Integer` на каждое число из диапазона `[-128, 127]`.

Таким образом, при **неявном** приведении чисел из этого диапазона к `Integer` не будет по-настоящему создаваться новых объектов, а вместо этого переменные будут получать ссылки на объекты из пула.

К чему это приводит? К неожиданному на первый взгляд поведению. Так объекты, полученные таким образм, будут равны в том числе с точностью до `==` (то есть, будут хранить одинаковые ссылки), в то время как для остальных объектов классов-обёрток это свойство не выполняется.

> Принимая во внимание такое поведение, можно заметить, что, например, в качестве возвращаемого значения функции стараются не использовать классы-обёртки без крайней на то необходимости. Стоит отметить, что такая необходимость, всё-таки может возникнуть

## Передача аргументов в методы

На самом деле, правила при этом не отличаются от правил при присваивании: примитивные типы копируются, а объекты – передаются по ссылке. На этом акцентировалось внимание, когда говорилось про отличия примитивных типов от ссылочных.

Однако, есть интересный пример, на который хотелось бы взглянуть:

```java
class Example {
    public static void foo(Integer x) {
        x = 3;
    }

    public static void main(String[] args) {
        Integer x = 1;
        foo(x);
        System.out.println(x); // 1
    }
}
```

Почему так происходит? На первый взгляд кажется, что раз функция принимает ссылочный тип, то его содержимое должно измениться снаружи.

Однако, если посмотреть внимательнее, то можно заметить следующее: в выражении `x = 3;` происходит boxing. То есть, число `3` преобразуется в объект типа `Integer`, на который уже будет совершенно другая ссылка. Предыдущий объект по этой ссылке не изменяется, что и приводит к наблюдаемому результату.

## `java.lang.String`

Первое, что стоит упоминания: `String` **не является** примитивным типом. Строка – это последовательность символов произвольной длины, в коде строковый литерал записывается в двойных кавычках вот так: `"this is a string"`.

Строки в Java имеют несколько критических отличий от C-style строк:

* `String` не содержит никаких терминальных символов, сигнализирующих о том, что строка закончилась. Это полностью самостоятельный класс, и в нём длина хранится в виде отдельного поля;
* `String` и `char[]` – два независимых друг от друга типа. То есть, строка в Java – это не то же самое, что и массив символов. При этом, из строки имеется возможность получить массив символов с помощью метода `char[] toCharArray()`. Обратное преобразование можно совершить, передав массив символов в качестве аргумента конструктора класса `String`;
* строки в Java неизменяемые. Это означает, что модифицирующие операции (например, конкатенация) будут возвращать новые строки

Поэтому при сравнении строк со строками в C++ более корректно сравнивать `java.lang.String` с `std::string`, потому что они намного ближе по концепции друг к другу (за исключением вопросов про неизменяемость).

### Полезные методы

`int length()` используется, чтобы узнать длину строки.

> Стоит обратить внимание, что у строк, в отличие от массивов, `length()` является методом, в то время как у массивов это – псевдо-поле

`char charAt(int index)` возвращает символ строки по его индексу. В отличие от Python, отрицательные индексы не поддерживаются. Если будет передан некорректный индекс, метод вызовет unchecked-исключение `IndexOutOfBoundsException`. Символы в строке нумеруются с нуля, как в массивах.

`String substring(int beginIndex)` и `String substring(int beginIndex, int endIndex)` возвращает подстроку исходной строки между указанными индексами. До Java 7 возвращался view на исходную строку, а после – всегда создаётся новая строка. Это асимптотически занимает больше времени, но при этом упрощает сборку мусора, так как на исходную строку не хранятся лишние ссылки. С этой точки зрения, учитывая неизменяемость строк, реализация, возвращающая view, оказалась непрактичной.

`boolean startsWith(String prefix)` и `boolean endsWith(String suffix)` используются для того, чтобы проверить, является ли одна строка префиксом или суффиксом другой.

> *Интересный факт:* в Java этот метод у строк существует ещё с Java 1.0, в то время, как в C++ аналогичный метод добавился только в 2020, через 35 лет после создания языка. Коммитет по развитию языка считали, что в этом методе у разработчиков нет необходимости 💩

`int indexOf(String needle)` и `int lastIndexOf(String needle)` используются для того, чтобы найти первое и последнее вхождение подстроки в строку. В случае, если строка не содержит такой подстроки, возвращается `-1`. Для поиска используется наивный алгоритм поиска, имеющий квадратичную асимптотику в худшем случае, поэтому его не стоит использовать в случаях, когда пишется код в критической к производительности секции.

> *Интересный факт:* часто, в контексте алгоритмов поиска подстроки в строке строку, в которой ищется подстрока называют haystack, а подстроку, которую ищут – needle. Это, очевидно, происходит от поговорки "искать иголку в стоге сена". К тому же это помогает подобрать мнемонику, чтобы не запутаться в описании сложного алгоритма, про какую из строк в конкретный момент времени идёт речь.

`String trim()` возвращает копию строки, в которой удалены все подряд идущие пробельные символы в начале строки и в конце. Пробельными символами, помимо самого пробела, также считаются символы табуляции и перевода строки.

`String replace(char oldChar, char newChar)` возвращает копию строки, в которой все вхождения `oldChar` заменены на `newChar`. В документации есть несколько восхитительных примеров игры со словами с помощью этого метода, например:

```java
"sparring with a purple porpoise".replace('p', 't')
// returns "starring with a turtle tortoise"
```

(`"Спарринг с фиолетовой морской свинкой"` превратился в `"С черепашьей черепахой в главной роли"`)

`String toLowerCase()` и `String toUpperCase()`, по аналогии с методами, которые ранее встретились в классе `Character`, возвращают копию строки в нижнем или верхнем регистре соответственно.

### Сравнение строк

В соответствии с ожиданиями, оператор `==` сравнивает ссылки на строки, а метод `boolean equals(Object other)` проверяет содержимое строк на равенство. Однако, строки имеют более богатый интерфейс, предоставляющий способы их сравнения.

Так, например, у строк имеется метод `boolean equalsIgnoreCase(String other)`, который сравнивает строки на равенство, игнорируя различия в регистре.

Помимо этого, строки реализуют интерфейс `Comparable<String>`, и как следствие имеют метод `int compareTo(String other)` для лексикографического сравнения строк. Аналогично методу для проверки на равенство у строк имеется метод для лексикографического сравнения без учёта регистра: `int compareToIgnoreCase(String other)`.

### Конкатенация строк

Этой операции нужно уделить особое внимание, потому что конкатенация – весьма распространённая операция, и нужно понимать, как не испортить производительность приложения неудачной конкатенацией строк в цикле.

Первый способ конкатенировать две строки – вызвать у одной из них метод `String concat(String)`. У него есть несколько особенностей:

* Если в переменной, у которой вызван метод `concat` хранилось значение `null`, очевидно, возникнет `NullPointerException`. Довольно очевидный факт, но он приводится для сравнения с другими способами конкатенации строк, которые обладают другим поведением в этих случаях;
* Аргументом этой функции может быть только строка (или объект, явно приведённый к этому типу)

Второй способ – использовать `java.lang.StringBuilder`. Вот, как он используется:

```java
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(',');
sb.append(" world!");

String s = sb.toString();
```

Теперь, если в метод `append` вместо какой-то из строк передать `null`, то не будет выброшено исключение. Однако, в строку-результат попадёт строковое представление `null`, то есть строка `"null"`.

Также, у метода `append` есть много перегрузок, принимающих разные типы параметров. Так, например, в примере кода можно заметить, что второй вызов `append` производится с `char` в качестве аргумента.

Аргументом использовать `concat` вместо `StringBuilder` являются случаи, когда нужно сделать небольшое количество конкатенаций, и все выражения уже являются строками. В таком случае при очень маленьком количестве строк будет получен выигрыш в скорости за счёт того, что не придётся создавать объект `StringBuilder`.

Аргументом предпочитать `StringBuilder` вместо `concat` служит то, что метод `append` имеет много перегрузок для разных типов данных. Но что самое главное – он выполняется за константное время (`O(1)`). В то время, как каждый вызов `append` выполняется за линейное время по длине строки-резальтата (`O(|n| + |m|)` в выражении `n.append(m)`). А уже метод `toString` выполняется один раз за линейное время по длине строки-результата.

Из этого следует, что при необходимости совершать конкатенацию в цикле, гораздо более предпочитаемым способом было бы воспользоваться `StringBuilder`. Потому что общая асимптотика последовательных вызовов `concat` в таком случае станет квадратичной.

> Почему `append` в `StringBuilder` работает за `O(1)`?
>
> `StringBuilder` представляет из себя связный список строк, а метод `append` – добавляет строку в конец этого списка, отсюда и асимптотика работы этого метода за `O(1)`.
>
> После чего, за один проход по всему списку метод `toString` может сформировать итоговую строку-результат.

Ещё одним способом конкатенации строк является оператор `+`. На самом деле, если заглянуть в байт-код, использование этого оператора на строках просто превращается в неявный вызов `StringBuilder`. Однако, в отличие от `StringBuilder`, программист явно не видит, в каком месте происходит создание нового `StringBuilder`, а в каком – вызов у него метода `toString`. Это влечёт за собой следующее: если оптимизатор Java не справится и сгенерирует что-то вроде создания нового `StringBuilder` на каждой итерации цикла, а потом а этого вызов метода `toString`, то это будет работать ещё медленнее, чем вызов `append` из-за накладных расходов на создание объекта.

К тому же, интересной особенностью этого оператора является то, что он неявно вызывает метод `toString` у своих аргументов. Рассмотрим следующий пример:

```java
Integer i = 1;
String x = "a";

x += i; // Неявный вызов метода Integer.toString()
x = x.concat(i); // compile error
```

Так как `+` по своей сути является синтаксическим сахаром над `StringBuilder`, то его можно использовать там же, где и `StringBuilder` при условии чёткого понимания, в каком месте в байт-коде будет создан новый объект `StringBuilder`, а в каком – вызван метод `toString`. Если же это не очевидно или оптимизатор не справляется с тем, чтобы не создавать новый `StringBuilder` там, где этого можно избежать, лучше явно использовать `StringBuilder`.

### Регулярные выражения

Стандартная библиотека Java имеет довольно богатый интерфейс для работы с регулярными выражениями.

Регулярные выражения задаются с помощью строк, которые затем, например, можно передать в `Pattern Pattern.compile(String regex)`.

> При необходимости несколько раз использовать регулярное выражение это даст ощутимый прирост в производительности, так как интерпретация регулярного выражения из строки – довольно ресурсоёмкая операция.

При этом, в регулярных выражениях довольно часто встречаются экранирующие последовательности (например, `\s` обозначает пробельный символ). Однако, в Java символ `\` сам по себе является экранирующей последовательностью. Поэтому, нужно держать в голове, что все символы `\` в регулярном выражении, заданном строкой будут выглядеть примерно так: `"\\s"`.

Строки поддерживают работу с регулярными выражениями, и у них для этого есть коллекция методов. Рассмотрим некоторые из них:

`boolean matches(String regex)` проверяет, подходит ли строка под указанное регулярное выражение (которое тоже задано строкой). Более многословный, но потенциально более эффективный способ это сделать, используя `java.util.regex.Pattern`: `Pattern.matcher(String str).matches()`.

`String[] split(String regex)` возвращает массив строк, на который разбивается исходная строка. С помощью регулярного выражения указывается разделитель подстрок. Разделитель не включается в подстроки, которые будут в массиве. Работает примерно следующим образом:

```java
String[] parts = "--aa-a".split("-");
// parts = ["", "", "aa", "a"]
```

В этом примере показано, какой вид будет у элементов результирующего массива, а также, что этот метод может вернуть пустые строки, если встретились несколько разделителей подряд.

У класса `Pattern` тоже есть метод для разделения строк: `String[] split(String str)`.

`String replaceAll(String regex, String replacement)` и `String replaceFirst(String regex, String replacement)` используются для того, чтобы заменить все или первое вхождение выражения, подходящего под регулярное выражение. В `replacement` можно использовать специальные последовательности, такие как `"$n"`, где `n` – номер скобочной группы из регулярного выражения.

Проводя параллель со скомпилированным в `Pattern` регулярным выражением, можно упомянуть, что у `Matcher` есть методы с соответствующей сигнатурой. Однако, `Matcher` позволяет производить более гибкие замены, например, с помощью методов `appendReplacement` и `appendTail`.
