Лекция 1

Биба и Боба живут в одной квартире. У каждого есть планшет с выходом в сеть, с которого они смотрят видосики, читают Твиттер,
и слушают музыку в VK.

Что происходит, когда Биба пытается зайти на vk.com?

* Чтобы куда-то отправить, нужна какая-то система адресации. Каждый копьютер обладает **IP-адресом**.
* IP-адрес весит 4 байта.
* Обычно записывается 4-мя десятичными числами через точку. Каждая часть от 0 до 255.

Пусть IP Бибы: 192.168.0.5. У vk.com тоже есть какой-то IP-адрес.

Для того, чтобы отправить запрос, нужно знать IP-адрес vk.com. Пусть мы его знаем.

Есть два разных способа передачи данных (в нашей картине мира):
1) (Глобальная сеть) Передача от Бибы на коробочку (пока какая-то магическая коробочка с антеннками), а из нее куда-то далеко (vk.com)
2) (Локальная сеть) Передача от Бибы на коробочку, а от нее на планшет Бобы.

Чтобы отличать компьютеры, которые есть в локальной сети от остальных, есть маска.

**Маска** тоже весит 4 байта. 
Маска выглядит следующим образом: n*[1] ++ (N-n)*[0]. Это говорит о том, что первые n символов обязаны совпадать, а
остальные могут быть какие угодно.

Если маска квартиры Бибы и Бобы выглядит как 11111111000000...... , то адрес Бобы: 192.168.*.* , пусть 192.168.0.4.
Проверка делается через побитовое "и".

Для того, чтобы передать данные за пределами локальной сети, есть GW (gate way): адрес компьютера в глобальной сети. Это адрес
коробочки.
Пусть у Бибы он 192.168.0.1.


Проблема: пользователей много, IP-адресов на всех не хватит. Поэтому часть адресов зарезервирована под
взякие нужды и с ними нельзя ходить в интернет.

Следующая группа зарезервирована:   
192.168.\*.\*
127.\*.\*.\*
10.\*.\*.\*
172.\*.\*.\*

На что тут надо обратить внимание:
1) С IP-адресом Бибы нельзя ходить во внешний мир. Коробка прячет этот адрес от внешнего мира. 
Q: У коробки, вроде, был адрес 192.168.0.1? Он же тоже заблокирован?      
A: Верно, но коробка передает данные дальше по проводу с адресом 194.*.*.*, который перекрывает адрес коробки.
2) Можно считать, что сети имеют древовидную структуру. Пусть в подъезде Бибы и Бобы в каждой квартире стоит свой роутер,
который является GW на уровне квартиры. И в подвале подъезда есть общий GW, который объединяет все роутеры в
подъезде. Для этого GW локальными компами являются роутеры.    
Дальше GW printer go brrrrrr
3) Как работает передача сигнала: по вот такому дереву маршрутизаторов просто идем путем через lca двух компов.
4) Коробка передает полученные данные всем, а тот, кому надо, уже прочитает
5) Часть коробок делает подмену адресов (NAT network address translation)
6) Шлюзы могут делать или не делать NAT в зависимости от настроек

Биба отправляет набор данных (пакет), что там должно быть:
1) Сами данные
2) IP-адрес получателя
3) IP отправителя

Как все работает?
Биба посылает данные vk.com:
1) Биба собирает пакет и отправляет маршрутизатору
2) Маршрутизатор смотрит, что данные нужно отправить в глобальную сеть, подменяет адрес (потому что NAT прописан в
его настройках) и отправляет данные следующему шлюзу.
3) В какой-то момент дошли до шлюза, у которого vk.com является локальным.
4) Все уходит по цепочке вниз

Данные добрались до vk.com, а чего теперь с ними делать?    
Нужно указать порт, куда их следует направить (а дальше уже программа, которая слушает порт их заберет и все 
сделает как надо).

Порт имеет номер [0, 65536]. Каждая программа, если ей нужны данные, то она говорит, какой порт она будет слушать.

В данных внутри пакета лежат сами данные и номер порта. Почему порт не снаружи? Потому что с точки зрения перемещения
данных между шлюзами, нам плевать на порт (на самом деле не плевать, но об этом дальше).

Пусть Биба магическим образом угадал и IP-адрес и порт. Вк все получил и обработал, а как теперь Вк понять, на какой
порт ему отправить данные?    

Как вообще узнать порт:
1) Если пишем сервер, то жестко фиксируем для него порт.
2) С другой стороны, если мы запустили браузер, то ему обсолютно пофиг, какой порт слушать. И тогда мы выбираем
случайный порт.

И теперь меняем слово "программа" на слово "сетевое соединение", т.к. программа может внутри себя слушать кучу портов.

Окей, vk.com отправил пакет, он дошел до маршрутизатора, а дальше куда? Мы же делали подмены.   

На самом деле, каждый раз, когда мы делаем подмену, маршрутизатор запоминает что он подменил IP,port на 
что новое IP_1, port_1. И потом делает обмен обратно.

А как хранить эти строчки и понять, что они не нужны?
1) Считаем, что марштрутизатор хранит строчки, пока может
2) Вместо со строчкой хранится время, когда ее последний раз использовали
3) Если строчки закончились, удаляются самые старые строчки

Из-за этого могут быть нарушения в сетевом соединении, когда с одного маршрутизатора открыто много сетевых соединений.
Например, данные мы отправили, а ответа не получили, т.к. нашу строчку стерли.

Решение: дать маршрутизатору несколько сетевых адресов. Если дать n сетевых адресов, то он в n раз больше сможет
добавлять строчек.

Есть такая штука: стек протоколов TCP-IP

Простая 4-х уровневая система (типа OSI):
* Application - здесь есть просто data
* Transport   - тут есть data, полученные с верхнего слоя, и port_отправитель, port_получатель: p1, p2 (data).
Новая информация как бы оборачивает то, что было написано ранее.
* Network     - IP1, IP2 (p1, p2 (data))
* Link        - MAC1, MAC2 (IP1, IP2 (p1, p2 (data))), MAC2 - MAC-адрес *шлюза*.

Вся эта радость уходит в сеть. Компьютер, когда получает пакет проверяет, указан ли его IP адрес или нет.
Если нет, то выкидывает, если да - то разворачивает и обрабатывает. Если есть нужный порт, то отправляем на порт данные,
если нет, то выкидываем.

Зачем нужен Link? Если бы его не было, схема была бы такая: отдаем данные шлюзу, он проверяет IP2, смотрит, что это не он,
выкидывает нафиг.

**МАС-адрес** - это просто номер сетевой карты устройства. Коллизии номеров есть, но вероятность этого очень маленькая.

1) Откуда взять МАС-адрес?
Отправим специальный пакет с IP адресом того, чей МАС-адрес нужен. Это устройство нам ответит и мы узнаем его
МАС-адрес.
2) Чтобы отправить пакет, нужно знать МАС-адрес того, кому мы его отправляем. А мы его не знаем. Поэтому есть 
специальный широковещательный пакет.
МАС-адрес: FF:FF:FF:FF:FF:FF проставляется у такого пакета. Этот пакет предназначен всем.

# Лекция 2

Замечания:
* App, Transport, Network, Link --- это 4 уровня протокола коммуникации (гугли OSI).

На самом деле, шлюз НЕ отправляет данные вышестоящему шлюзу.

* Простое устройство шлюза, 2 интерфейска: коробочка с антенками, которая по WiFi подключается к устройствам,
по проводу (Ethernet) подключается в вышестоящему шлюзу.
* В реальной жизни 24, 48, еще больше разъемов, у каждого свой интерфейс. Каждый из этих интерфейсов обладает 
собственным IP, маской, шлюзом.

Когда приходит пакет, который надо передать дальше, то надо еще сначала понять, а на какой именно интерфейс из кучи нам
его передавать. Для этого у каждого шлюза есть **таблица маршрутизации**.

Таблица маршрутизации позволяет понять, на какой физический интерфейс (физическая сетевая карта) нужно передавать пакет.
На обычном компьютере такая штука тоже нужна, т.к. на нем тоже несколько сетевых интерфейсов. Есть wifi,
проводной интернет, докер, который внутри компьютера организует локальную сеть и т.д.

**Здесь должна быть картиночка**
 
Хотим отправить пакет на компьютер с известным IP. Как понять, на какой интерфейс его отправить?
* Пробегаем по интерфейсам в порядке возрастания/убывания (зависит от ОС) метрики.
* Ищем первую строчку, которая подойдет (первую пару IP-mask, в которую наш IP попадает)
*  

**Добавить пример с картинкой**

Что значит запись в таблице маршрутизации: мы умеем добираться до IP адреса destination, и тех, кто лежит с ним в
локальной сети (задана маской), с помощью Gateway (если стоит *, то просто напрямую через Iface передаем данные).

**DNS**(Domain name service) --- протокол, нужен, чтобы узнавать IP адресс по доменному имени.

Биба хочет отправить данные на vk.com, но не знает IP. Для этого он отправляет запрос с доменным именем своему DNS.
Если DNS знает такое имя, то он отправляет Бибе IP, иначе спрашивает у вышестоящего DNS.

Так мы все идем выше по DNS и спрашиваем, пока либо не найдем vk.com, либо не дойдем до корневого DNS.

**Корневой DNS** не знает IP vk.com, но он знает, у кого спросить. Он знает, кто отвечает за `*.com`, а тот уже
знает, кто отвечает за `vk.com`, и вот оттуда мы уже получаем IP.

Вот это все называется **рекурсивный DNS запрос**.     
Недостаток: очень большая нагрузка на участников цепочки     
Плюс: каждый участник цепочки может закешировать себе ответ, и, например, когда Боба тоже пошлет запрос, DNS сразу
выдаст ему ответ из кэша.

Второй тип DNS запросов - **нерекурсивные**.    
Наш DNS спрашивает у вышестоящего про vk.com, тот отвечает "Не знаю, спроси у этого". Мы посылаем запрос другому DNS
и так продолжается, пока не найдем IP.     
Плюсы: Меньше нагрузка на все DNS     
Минусы: Больше нагрузка на наш DNS

Вопрос: кому принадлежат корневые DNS сервера?     
* Их около 12
* Они имеют имена A, B, C, D, E, ....
* На каждую часть света по 1 примерно (бывает больше)
* 50% и 1 акция принадлежат правительству США.

Зачем нужно 4 уровня сетевого протокола:
* Не хотим, чтобы приложение зависило от физического способа передачи данных. Уровень Link будет разный в зависимости от
способа передачи. Отделяем всю остальную информацию от физической реализации передачи.
* Уроверь App имеет информацию только о данных, а как кому и зачем их будут передавать - это уже не наше дело.
* Net нужен, чтобы иметь возможность делать маршрутизацию, работать с IP адресами.
* Разделение TR и Net нужно (это будет рассказано дальше)


# Лекция 3

Протоколы, которые есть на разных уровнях:
1) App - http, https, std, smtp, ssh
2) TR - TCP, UDP
3) Net - IP, ICMP
3.5) - ARP
4) Link - WiFi, PPP, Ethernet, ADSL, LTE, so on