**Что может быть на летучке**
1. 100% будет что-то на различие TCP-UDP
2. 

# Лекция 1

* В Java можно работать только с пакетами уровня Application и Transport. 
 
**Сокет** -- низкоуровневый API для пересылки байтов по сети.

* Поддерживает протоколы TCP и UPD.
* Поддерживают адресацию IPv4, IPv6.

## UDP socket
* При создании сокета ОС выделяет порт и закрепляет за этим сокетом.
* Создаем сокет и пакет, который хотим передать.
* DatagramPacket принимает массив байтов, длину массива и адрес получателя (IP адрес и порт).
* От пакета можно дальше получить всяку инфу: размер сообщения, кто отправил, ...

```java
try (DatagramSocket s = new DatagramSocket(?port)) {
    DatagramPacket p = new DatagramPacket(buf, buf.length, remoteAddress);
    s.receive(p);
}
``` 
**Важно:**
* Очень желательно, чтобы размеры пакета не превышали ограничения на уровне TCP-UDP и 1000 байт (не 1024, т.к. еще 
метаинформацию надо запихать куда-то)
* Если размер buf больше `buf.length`, то первые `buf.length` считаются, а остальные останутся в сокете, тогда их можно
будет считать при следующем вызове команды `receive()`.
* `receive()` -- блокирующая команда.

**??** Почему 1000 байт? Как работает множественный вызов `receive()`?

## TCP сокет

* **Socket** -- TCP сокет в Java.
* Сразу устанавливается соединение, и если не вышло, то конструктор кинет ошибку.
* Не создаем пакет, а пишем данные в стрим сокета.

```java
Socket socket = new Socket ("localhost  ", 11111);

OutputStream os = socket.getOutputStream();
os.write(requestBytes);
os.flush();

InputStream is = socket.getInputStream();
is.read(responseBytes);
```
* Метод `flush()` сбрасывает все, что накопилось в буфере.

* **ServerSocket** -- серверный сокет. Отличие от обычного в том, что по нему нельзя общаться с клиентами.
* Чтобы получить сокет, по которому можно общаться с клиентом, нужно получить его через `serverSocket.accept()`.
Так сделано потому, что нам нужно выделить отдельный порт для общения с отдельным клиентом. За нас это делает Java
(или ОС?).
* 

```java
ServerSocket server = new ServerSocket(11111);
Socket socket = server.accept();

InputStream is = socket.getInputStream();
is.read(requestBytes);

OutputStream os = socket.getOutputStream();
os.write(responseBytes);
os.flush();
```
**Важно**:
* Команды `accept()`, `read()`, `write()` являются блокирующими.

* Обработка большого количества клиентов.

Варианты архитектуры.

1. **Один поток на всех**
    1. В один момент времени работаем только с одним клиентом.
    2. Клиентам в очереди на соединение придется ждать.
    3. Всего N потоков.
2. **Один поток на каждого клиента**
    1. Можем обрабатывать много клиентов одновременно
    2. Тратим время на создание потоков (если клиентов много)
    3.Хочется переиспользовать созданные потоки.
3. **Фигачить тредпул**
    1. Что класть в тредпул: обработку клиентов или отдельные таски?
    2. Если тредпул обрабатывает задачи одного клиента, то часто это фиговая идея.
        1. Не можем обрабатывать клиентов больше, чем потоков.
        (Если тредпул фиксированного размера). Нужно M потоков.
        2. Тредпул разростется и будет уходить время на переключение контекста (если тредпул
        не фиксированного размера).
    3. Класть в тредпул задачи клиента.
        
## Блокирующая архитектура.

* Заведем M потоков в тредпуле для обработки задач.
* На каждый поток заведем еще один поток, который будет периодически тыкать клиента,
брать его задачи и скидывать в тредпул, и потом возвращать результат клиенту.
* Всего потоков N + M
* Реально их этих потоков работают M.
* В потоке клиента происходит следующее: поток читает данные из интпут стрима клиента
(`read()` блокирующая операция), дальше отправляет данные в тредпул и ждет ответа
(тоже блокируемся), дальше берем ответ и записываем его клиенту (тоже блокирующая).
* В отличие от схемы 1, где работают N потоков и мы не контролируем,
сколько из них реально работают, тут работают M потоков.

**Важно**:
* Если задачи долго обрабатываются, то клиенты могут долго ждать ответ, что обычно
является плохим сценарием.
* Не поддерживаем одновременное выполнение заданий от одного клиента. Он не может
отправить сразу несколько заданий, а потом в светлом будущем получить на них ответы.

Это можно исправить, заведя еще по одному потоку на клиента.
Ввод в одном `SingleThreadExecutor`, вывод в другом.
        
Если бы мы научились понимать, есть ли что-то в сокете или нет, без блокировки, то мы смогли бы сильно сократить
количество потоков.

## TCP vs UDP
* 

## Java NIO

* NIO -- New Input/Output
* Сокеты -> Каналы

### Каналы VS Сокеты
* Канал двунаправленный - из него можно и читать и писать в него
* Стримы кушают байты, Каналы могут кушать разные данные.
* Появляется специальная сущность **буфер** - это порция данных, которую мы отправляем в канал.
* Можно делать асинхронное чтение/запись
* Могут быть блокирующими и неблокирующими.



### Каналы
* `FileChannel` -- читает данные из файлов и в файлы
* `DatagramChannel` -- передача UDP
* `SocketChannel` -- передача TCP
* `ServerSocketChannel` -- прием входящих TCP соединений. На каждое новое создает отдельный `SocketChannel`.

### Буферы
* Блок памяти, в который можно писать данные, и читать из него.

Основные реализации:
* `ByteBuffer`
* `CharBuffer`
* `DoubleBuffer`
* `FloatBuffer`
* `IntBuffer`
* `LongBuffer`
* `ShortBuffer`

Типичное использование `Buffer`:
1. Записать данные в буффер
2. Сделать `buffer.flip()` -- переводит буфер из режима записи в режим чтения.
3. Чтение данных из буфера
4. Вызов `buffer.clear()` или `buffer.compact()`.

По смыслу, буффер - это массив с
* заданной вместимостью (capacity)
* границей, сколько данных максимально можно читать или писать (limit)
* текущей позицией чтения или записи (position)

### `buffer.clear()` VS `buffer.compact()`
* `clear()` удаляет данные, переводит position в 0, а limit в capacity
* `compact()` переписывает остаток в начало, ставит limit в capacity, а position - на первое свободное место.

* Создание буфера: `ByteBuffer.allocate(int capacity)`
* Запись данных в буфер: `inChannel.read(buffer)` -- читаем ИЗ канала В буфер ИЛИ `buffer.put(smth)`
* Чтение данных из буфера: `inChanne.write(buffer)` -- записываем В канал ИЗ буфера ИЛИ `buffer.get()`

### Scatter/Gathering
* **Scatter** -- команде чтения из канала можно передать несколько буферов. Сначала читаем в первый, потом второй, и тп
* **Gathering** -- команде записи в канал можно передать несколько буферов.

**Зачем это надо?** Обычно сбщ выглядит как заголовок + данные + что-то еще. Если мы знаем размер заголовка, то можем
создать буфер такого размера и передать 2 буфера. Тогда заголовок попадет в первый буфер, а дынные в другой, и не надо
ничего ковырять руками.

## Селекторы

**Селектор** -- это магичесая штука, к которой привязаны несколько каналов, и которая умеет говорить, в какие из каналов
можно писать, а из кого можно считать данные.

**Важно**: Селекторы работают с каналами только в неблокирующем режиме.

* `Selector.open()` -- создание селектора.
* `channel.configureBlocking(false)` -- *не забыть перевести канал в неблокирующий режим*.
* `SelectionKey kye = channel.register(selector, selectorKey.ON_READ)`

**SelectionKey** -- штука, которая хранит селектор и канал, с которыми связана, свойства, на которые зареган селектор,
состояние ready (произошло ли интересное свойство) и каие-то прикрепленные объекты

```java
while (true) {
      int count = selector.select();
      if (count == 0) {
         continue;
      }
   Set keys = selector.selectedKeys();
  
      Iterator itor = keys.iterator();
      while (itor.hasNext()) {
        SelectionKey selectionKey = (SelectionKey)itor.next();
         selectionKey.remove();
         // process channel from key here
      }
   }
```


## Неблокирующая архитектура
* **Неблокирующая команда** -- (нет точного определения, но можно думать так) команда, которая выполняется быстро.
Например, чтение. Если получилось быстро прочитать, то вернет данные, иначе 0.


### Проблемы неблокирующей архитектуры
1. Селектор -- узкое место. Если потоки активно пишут/читают, а задачи небольшие, то в селектор начинает тормозить. В
блокирующей архитектуре можно решить эту проблему увеличением ядер, но тут не получится.
2. Клиенты **почти всегда готовы к записи**, но появляются данные для отправки куда реже. Поэтому селектор будет находится
часто в активном ожидании. Можно сделать отдельный селектор для записи.

## Неблокирующая архитектура с отдельными селекторами на чтение и запись.
* В селекторе на чтение клиента регистрирует тот, кто его принял (т.е. поток, который делает `accept()`)
* В селекторе на запись клиента может регистрировать либо тредпул (плохо), либо сам селектор.

### Еще тонкости
1. Надо не забыть делать команду `wakeUp()` каждый раз, когда хотим зарегистрировать клиента в селекторе (иначе он
не будет выходить их блокировки).


**Почему плохой способ:**
1. Регистрация может блокировать работу тредпула и вообще тупо быть долгой
2. Тредпул отвечает за логику, за которую не должен (думает о том, как отправить сбщ, а не просто его делает
и складывает в буфер)

**Регистрация из селектора**:
1. Просыпаемся и проверяем интересные действия
2. После этого побегаем по буфферу на запись и проверяем, для кого готовы данные
3. Регистрируем нужных клиентов.
    1. Положить данные в очередь на отправку и пометить клиента как new.
    2. Разбудить селектор.

Если сделать в другом порядке, то произойдет следующее:
* Увидим, что клиент новый, зарегаем его
* Увидим, что у него нет данных, и кикнем его.


**Проблемы с регистрацией канала из селектора**:
* Надо разбудить селектор и зарег. его
* К тому моменту, как начнем делать регистрацию, селектор может снова заснуть.
* Есть три решения:
    * (не очень хорошее) Взять блокировку, разбудить селектор, зарег. канал, отпустить блокировку.
    * (подходит только для селектора на чтение) Делать селект с таймаутом.
    * Забить на это, само когда-нибудь зарегистируется.

### Зачем три флага?
Мы хотим регистрировать клиента только в тот момент, когда для него есть полное сбщ?
В селекторе у нас в цикле происходит слежующая последовательность действий:
1. Делаем селект
2. Обрабатываем результат селекта
3. Регистрируем нужных клиентов.

Флаг new ставит тредпул, когда у него готово сбщ для клиента.

Что происходит с загеристрированным каналом: каждый раз, когда он готов для чтения, кидаем в него кусочек данных.
Когда все данные перекинуты, мы должны его кикнуть. Если мы ему поставим флаг new, то при следующем пробуждении он
сразу зарегистирует канал, даже если для него нет готового сбщ. Поэтому мы ему ставим флаг "разрег.", и вот когда для
него уже появится сбщ, тогда мы ему поставим флаг new.

# Асинхронность и блокировки
* **Асинхронность и блокировки ортогональные понятия**, т.е. вывод может быть блокирующим и синхронный и тп
* В Java неблокирующий вывод **всегда синхронный** (т.к. создатели языка считают, что он и так быстро работает)
* В Java асинхронный вывод быстрее, чем неблокирующий.

## Асинхронные каналы

**`AsynchronousChannel`**
* Результат типа `V`.
* `Future<V> op(..., A attachment, CompletionHandler<V, A>)`
* Отмена операции - `future.cancel()`

**CompletionHandler<V, A>**
* Успешное завершение `completed(v, a)`.
* Ошибка `failed(exception, a)`.
* `A` -- это тот самый `attachement`, который мы присоединяли.

### Группа асинхронных каналов
* Это типа обертки над тредпулом, который говорит, что колбеки из этой группы потоков исполняются вот в этом тредпуле.
* `AsyncServerSocketChannel ss = AsyncServerSocketChannel.open(group)`
* 